{"pages":[],"posts":[{"title":"ViewPager配合Fragment懒加载的一个坑","text":"ViewPager搭配Fragment做懒加载，这个很常见。需要小心的是Fragment在ViewPager中的生命周期，这个不多说。 最近遇到一个坑，这个坑的关键点是 1ViewPager.setOffscreenPageLimit(); 假设通过这个方法设置了一个值（比如2），然后在ViewPager中滑动加载了2个Fragment后，第三个Fragment的加载会出现问题，具体表现是该调用的方法都有调用，但是就是数据加载出问题。 数据加载我是用了RxLifecycle绑定到FragmentEvent.DESTROY_VIEW，初步怀疑是生命周期在作祟。 目前的解决方法是先将setOffscreenPageLimit设置为和自己加入的Fragment数量一致。比较好的解决方法是自定义ViewPager实现懒加载。","link":"/article/dev/fbb3d3e5.html"},{"title":"hexo与github建站记","text":"前一段时间Google开放了.app的域名申请，当时我搜了一下自己想要的一个域名，但是感觉有点小贵就没下手，没想到过了几天这个域名就没了。所以火急火燎的买了现在这个域名，但是一时间没想好要干嘛，思来想去的不如就建个小博客站吧。 准备阶段GitHub首先是先在自己的GitHub上创建一个新的Repository，名字为xxx.github.io，这个xxx必须是自己GitHub的用户名，否则不能成功。 创建好之后进入该项目的Settings，找到GitHub Pages 这里要选择自己的显示的分支，网上有人说一定要建gh-pages分支，其实没必要。另外Save之后就无法修改了，所以这里要注意一下。 GitHub Pages支持Jekyll，不过我用hexo，所以这个不用管了。 Custom domain这个是绑定自定义域名到你的github.io上。此处表面上是只能输入一个，实际上可以在项目里建立一个CNAME文件，往里面写入多个自己的域名都行。 Enforce HTTPS 这个重点说一下。今年五月份起 GitHub Pages“支持”HTTPS，这个支持的意思是从五月份起，新建的github.io都必须开启HTTPS，否则不能访问。这里就有个坑，此处暂时不表。 自定义域名网上域名商有很多，国内的域名商需要备案，网上很多人说建议在国外的域名商买域名，这个就见仁见智了，看自己需要。 有一点要注意的是，购买域名后要对域名的DNS做处理，否则是无法访问的。我这个域名实在GoDaddy上买的，GoDaddy的管理页就能设置域名的DNS域和转发网址，嫌麻烦的话其实在里面跟github.io绑定就行。 我用的是Dnspod，目前免费。使用方式是先注册，然后在里面的控制台添加域名（就是自己申请的自定义域名）。 添加完之后点进去，就可以添加记录： 网上一些帖子告诉你这里填的A记录的IP是错的，现在由于要使用HTTPS，所以要用troubleshooting-custom-domains这个页面内提供的四个IP： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 由于Dnspod只能免费填2个A记录，所以随便选2个IP填就是了。 之后要去自己买的域名的控制台那边修改DNS域： 图上是修改好的样子。 上述步骤完成后等一段时间，可以用dig命令（我是linux平台）检测一下自己的github.io和自定义域名的A记录是否一致。 坑这里就是1.1里提到的坑。当你设置完上述的所有东西之后，回到GitHub项目的Setting页，很大可能你会在GitHub Pages处看到两种提示，大概是： 自定义域名不支持HTTPS HTTPS证书正在处理下发 这两种提示2选1，都有可能出现。问题是第一个提示，这个非常误导人。我当时以为是我的哪个设置弄错了，折腾很久，还给github.com/contact发了个工单。 但实际上这两个提示根本没什么卵用，你所能做的就是等。一般一个晚上的时间就能好，实在不行就给github发工单。 HexoHexo是基于Node.js的，所以使用之前要先安装好Node，再用npm命令安装。 Hexo的使用其实很简单，主题页很多，官网提供的theme有大概200多个（吐槽一下，大多都是性冷淡色调，虽然我用的这个也是）。唯一要注意的是，网上很多比较过时的文章，里面提到的用法现在都不支持了。事实上官网本身就有简体中文的教程、文档，而且下面还有评论，多看看大概就知道怎么使用了 值得一提的是，Hexo的发布每次都是重新生成所有文件，再全部覆盖提交的GitHub上，所以要注意把不想被覆盖的文件添加到Hexo的source目录里。 还有一点是，Hexo发布到GitHub上的文件都是生成后的文件，Hexo自身的源文件不会上传上去。一种解决方法就是在自己的github.io项目上新建一个分支，将当前的Hexo文件都保存在新分之上。","link":"/article/default/86b00fba.html"},{"title":"你可能是数据推荐的受害者","text":"如果你是一名手机应用开发者，应该对友盟之类的统计SDK有所了解。如今这些第三方统计平台越来越吃香，因为各大厂商平台能利用这些数据做的事情，太多了。 最常见的，就是很多平台引以为荣的推荐系统。 最先让普通人体会到数据推荐的威力的，应该是网易云音乐。通过统计用户在网易云音乐上常听的音乐类型，逐步构建出一个用户的喜好模型，根据这个模型来为用户推荐音乐。从市场反应和用户反馈来看，这个推荐系统相当成功。 只要有效数据足够，方法论正确，通过手机收集到的用户数据和行为习惯，互联网公司真的比你自己更了解你。 何况这个时代，收集数据的不仅仅是手机APP，网页、搜索引擎、甚至是线下商店，大家都在无孔不入地收集每个人的数据。 有了这些数据，通过精准推荐，你永远都能在平台上看到你喜欢看的。 这样好吗？对于平台而言当然好，当用户发现这个平台好像大部分是自己感兴趣的内容，用户对平台的粘性就会变高，用数据表达的话，就是留存率增加，使用时长增长。 但是反过来说，对用户而言，你只能看到平台想你看的东西，或者说，你只能看到平台认为你想看的东西。 过去看新闻的时候，某些类型的新闻我可能比较关注，比如科技、民生类的，有一些是不太关注的，比如财经、国外政治类的。但是不关注不代表不看，比如某些时候可能我接触了一些其他知识，对某些之前不关注的新闻有了些许兴趣，那么当新闻实时发布出来时，我就能及时获取到信息；甚至就算不关注，但起码我会看到新闻标题，让我知道世界上发生了这么一回事。 现在看新闻，如果我点击科技、民生类的新闻比较多，可能过一段时间后，这个新闻平台就会开始自作主张地把这类型的新闻都推给你，而其他类的新闻在你浏览的版面上，占比会越来越少，甚至有段时间一条标题都看不到。 这意味着，数据推荐在迎合口味的同时，还把视野的广度给压缩了。这对很多人而言，会形成一种被动的“幸存者偏差”，仿佛这个社会就被你眼前“被推荐”的一切所充斥着，根本不会发生其他你不愿意了解的事情。 本来国家在信息屏蔽上就无所不用其极，数据推荐反而把这种趋势越推越烈。 举个例子，微博过去是很多突发、能让社会关注度很高的事件的消息始发地和传播地，过去刷微博的时候，会很容易就能刷到这些东西。但是近年以来，这些内容在用户充满被推荐的首页上很少出现到，甚至需要用户去搜索才能看到内容。 可以说，数据推荐在进一步加剧群众的无知。 其实数据推荐是一项很好的技术，精准的推荐系统能让广告收益更高，让平台更能抓住用户等等。但问题是，这些平台，好像很少能让用户选择是否接受推荐。 比如百度，如果我经常在百度上搜索计算机开发技术类的关键字，而某一天我可能希望搜索一些与此无关、但包含该关键字的内容，往往百度还是会优先在搜索结果上把技术类内容展示给我；又或者是知乎，知乎首页充斥着我关注的话题、我回答问题的相关内容和我提问的相关内容，但有时候我在知乎上并不只是想看这类东西。过去知乎还没有这种强相关的推荐首页时，可以在某个页面里看到其他人实时发的问题，这些问题涵盖不同方向类别，这让我可以挑一些还没人回答过的、对某些方面有经验或者兴趣的问题作答。而现在，知乎早就把这个功能去掉了。 如今数据推荐就像是应用里的隐私声明，你只能选择接受——说难听点，你只能选择被数据推荐强奸你的视野。事实是，数据推荐很有趣，但有的时候，我应该有选择不被推荐的权利。","link":"/article/default/4da69769.html"},{"title":"The ABC of Dart Part 1 - 基础","text":"前言近期对Flutter有兴趣，但这个东西要用Dart来写应用，只能先入门一下这门语言。 目前把基础看了一部分，总体而言，Dart和目前比较火热的JavaScript、Kotlin一样是一门脚本式语言，支持函数式编程，函数依然是第一公民，不过Dart对于对象的支持和定义更详细。另外，Dart运行在自己的Dart VM上，和其他的JVM语言不同，所以无论是使用Flutter或者是Dart，都需要先安装Dart VM。 至于IDE，我用的Android Studio，安装上Dart插件即可。 Hello World!和C语言一样，Dart的程序入口在main函数： 123void main()&#123; print(\"Hello World\");&#125; 三行代码就可以在一个*.dart文件中运行，不需要import什么东西。 对象类型之所以说是“对象类型”，是因为在Dart中一切皆为对象，只是针对不同的对象有不同的默认类型。因此，所有对象的默认值都为null，判空不用像js那么夸张了。 Object先介绍Object，就如上面所说，一切类型都是Object或者Object派生的。如果点开Dart中的object.dart，第一句注释就是： The base class for all Dart objects. 即所有类型都隐藏式继承了Object，如Java一样。 dynamicdynamic表示任意未知类型。注意未知这个词。在Dart中，Object和dynamic都能表示所有类型。关于这一点，刚开始接触时确实很困惑——既然Object已经能表示一切类型，那dynamic是用来干嘛的？ 举个例子，我创建一个类ClassA，其中的有一个成员函数为a： 12345class ClassA&#123; void a()&#123; //TODO &#125;&#125; 我声明一个函数，叫做func1，假设函数定义如下： 1234void func1(Object object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 因为ClassA默认继承了Object，所以在给func1这个函数传参时，我们可以传入ClassA的实例。但是在编译时，编译器会报错，告诉我们第(2)行代码是不能编译过去的。因为函数func1声明了函数参数类型为Object，它只能调用Object的方法。 但如果我把func1的参数改为dynamic： 1234void func1(dynamic object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 此时编译器则可以编译运行。 为什么呢？前面已经说了，Object是所有类的基类，而dynamic代表任意未知类型。两者功能基本一样，但是当使用dynamic来声明参数时，你可以通过该参数调用任意函数或变量，而编译器不会报任何异常。因为dynamic修饰的变量在编译器眼中看来，它是属于未知的，编译器不知道这个变量是否真的有这个函数或者变量，所以编译器选择闭嘴。 所以什么时候应该显示声明参数为dynamic呢？比如说我有一个类ClassA和ClassB，它们是两个没有任何关系的类，但是它们有两个共同的函数a，那么函数func1就能接受ClassA和ClassB的实例并且在内部调用函数a，而编译器不会对此报错。 但是官方也说到，最好还是不要用这种方式，dynamic应该尽可能不用，因为它不会被编译器检查，这样会导致程序不安全，程序员看着也很难猜测这种参数是什么类型。毕竟动态语言太过于“动态”就很难看了。 值得一提，Dart的静态检查和动态检查都很优秀，语言虽然是动态的，但是写起来跟静态强类型的语言相差不大。 var很多语言都有var关键字，作用基本都一样，表示类型为动态推断类型，编译器会将var声明的东西根据赋值反推类型。比如： 12var p1 = 1;var p2 = \"2\"; 在IDE中，这样在IDE中，能实时看到p1的static type为int，p2的static type为String。通过打印各自的runtimeType，也能看到和上述static type相似。 接下来有一点就有点意思了。如果我这样写： 123var p3; //(1)p3 = 1; //(2)p3 = \"2\"; //(3) 如果这样写，是可以编译、运行的（我目前的版本为Dart VM Version: 2.0.0-dev.54.0，往后的版本就不好说了）。 因为在（1）中，p3被动态推断为dynamic类型，所以在（2）中p3可以赋值为int，在（3）中可以赋值为String。在IDE中可以看到p3的static type为dynamic，而分别打印（2）、（3）时的runtimeType则分别为int和String。 所以，使用var最好是及时赋值，让编译器可以推断出实际类型，否则推断出类型为dynamic后，往后调用可能会出现不安全的情况。 num所有数字类型都继承自num，而数字类型也就只有2个： int - 表示任意长度的整数 double - 表示双精度浮点数 Dart中没有float、long、short、byte这些类型，统统用以上两种表示。 String字符串类型。顺带一提Dart也没有char类型。 Dart中的字符串支持+操作符，即： 12String str1 = \"abc\";String str2 = str1 + \"d\"; //str2 = \"abcd\" String支持在字符串中插入变量和代码，如： 123String str1 = \"abc\";String str2 = \"$str1\"; //str2 = \"abc\"String str3 = \"$&#123;str1.compareTo(str2)&#125;\" //str3 = \"true\"; 字符串前面加r，可以避免转义作用，声明该字符串为原始字符串： 12String str1 = \"\\n\";//输出换行String str2 = r\"\\n\";//输出\"\\n\" bool布尔类型，这个不用多说。 这些就是常用的基本类型，剩下的容器类型迟些再说。 const和finalconst和final都用于修饰不可修改的常量，唯一的不同点是在其声明时： const声明的常量是编译时常量，即编译时就需要确定值，所以声明时需要指定明确的值。 final声明的常量是运行时常量，即实际运行时才确定常量的值。 例如： 12345const int p1 = 1; //(1)final int p2 = 2; //(2)const int p3 = p1.compareTo(p2); //(3)final int p4 = p1.compareTo(p2); //(4) 在上面的代码中，（1）、（2）、（4）都可以编译运行，（3）在编译时则会提示错误。","link":"/article/dev/53564420.html"},{"title":"The ABC of Dart Part 2 - 函数","text":"函数的写法跟其他语言基本大同小异，如下： 123int func1(String str)&#123; return int.parse(str);&#125; 在以上的函数func1中，声明了返回值为int类型的对象，函数参数为String，这是一种标准写法。 函数的简写动态脚本语言，或者函数式编程语言，特点之一就是函数可以简写，如： 12345678910111213int func1(String str)&#123; return 1;&#125;func2(String str)&#123; return 1;&#125;func3(str)&#123; return 1;&#125;func4(str) =&gt; 1; 因为在Dart中类型是可选的，所以像函数func2缺省声明返回值类型、函数func3缺省声明参数类型的写法都可以，在这种情况下，编译器默认将缺省声明类型的都声明为dynamic。不过个人建议还是不要这样省略，dynamic会让程序员感到困惑。 函数func4是Dart提供的一种新的写法，类似于Java的lambda，当函数内只有一行语句时，可以用=&gt;来简写，即func4代表的函数类型和func3、func2一样。 函数对象 - Function前面说过，Dart中一切皆为对象，函数也不例外，它的对象类型为Function。 12345void func1(String str)&#123; //TODO...&#125;print(func1 is Function);// 打印true 像这样，通过Dart的is关键字用来判断类型，可知函数func1的类型就是Function。 但就我的理解，Function对于函数而言，就是一个基类。所有函数都的类型都基于Function，而每一种函数都有其特定的类型。 比如，上述的函数func1，可以用对象的概念套进去，即func1的基本类型是Function，实际类型是(String) -&gt; void，而fucn1则是这个实际类型的实例的名称。 我认为，需要先理解这个概念，才能明白为何把函数称为第一公民，为何认为一切皆对象。不仅仅是Dart这么语言，目前大多的动态语言、函数式语言都是类似的这种设定。 闭包函数作为一种对象，既然有匿名对象，也就有匿名函数，如下： 12345678//(1)(String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125; 像(1)、(2)这种把函数名、返回类型缺省的写法就是匿名函数。得益于函数也是对象这个概念，匿名函数这种写法才能实现。 以(1)为例子，匿名函数的写法舍去了函数名和返回类型，编译器会自动推断这段函数的返回类型，同时这段函数的实际类型为(String) -&gt; String。 如果这样一看，就像把一段封装好的逻辑包裹在函数这个对象的体内，因为函数自为对象，所以这个函数具备传递性，它可以被任意拿去调用，而不再像面向对象的语言一样，函数方法依附于实体类，这里就引申出函数式编程最重要的概念：闭包。 函数作为一种对象，因此可以作为返回值，也可以作为参数被传递。关于闭包的概念，寥寥几句无法说得清除。这里给出一种比较思路：比如在Java中，函数方法是作为一个对象的成员，我们要调用一个函数方法，调用它的这段逻辑，必须先传递对象，获取对象；反过来在Dart中，我们也是需要传递对象、获取对象，只是函数此时变成了一个对象，实际上我们依然在跟对象打交道，只是函数对象的出现使得一段逻辑本身就能被打包成一个可传递可获取的对象。 但是闭包不仅限于表示一段函数，而是一段包含了上下文环境的函数，这里还是不多说，只用一段代码表示一下 1234var func = (int a)&#123; int b = 4; return (int c) =&gt; a - b - c;&#125;(1); 在这段代码中，这段代码先定义了一段匿名函数，我们把该匿名函数叫做f1，f1的类型为(int) -&gt; Function，表示返回值是函数。然后我在匿名函数f1后面写上(1)，表示调用f1，传入参数1。f1的内部声明了一个变量int b = 4，并返回了一段匿名函数，我们把这段匿名函数叫做f2，f2的类型为(int) -&gt; int。因为我们调用了f1，所以立刻返回了f2并赋值给声明为动态推断类型的变量func，所以func的类型就是Function，它的实际类型就是f2这段函数。 注意这里的f2函数，其实携带着它的上下文环境——即int b = 4这个变量的。关于这个上下文环境不再多说，此处只作为一个例子。而从这个例子也可以得知，闭包的内存消耗比一般的对象可能要大，因为它包含了上下文环境。 回到开头所说的匿名函数，因为它缺省了函数名，所以在声明一段匿名函数时，必须立刻给它赋值，或者立刻执行它。所以开头的代码(1)、(2)应该这样写： 12345678//(1)var func1 = (String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125;(\"world\"); 注意： 将匿名函数赋值给某个变量时，需要将变量声明为var或Function。 匿名函数无法在函数外或类外立刻调用，只能声明。 typedeftypedef是Dart中的关键字。我的理解是用于定义函数类型，即将一种函数类型定义成一种对象；而网上的说法是typedef用于定义函数类型的别名。 1typedef int Compare(Object a, Object b); 在上述代码中，将(Object, Object) -&gt; int这种函数的实际类型给予了一个具体的名称Compare，这意味着，一旦任何一个函数的实际类型是(Object, Object) -&gt; int，则这个函数的实际类型等同于Compare。例如： 12345int compareFunc(Object a1, Object b1)&#123; return 0;&#125;print(compareFunc is Compare);//打印true 上述代码中的函数compareFunc的实际类型为(Object, Object) -&gt; int，所以用is来与Compare作判断的结果为true。 之前说过Function代表函数类型，所以作为一种类型，也是可以定义为函数的返回值类型和参数类型。如： 123Function getFunc(int a)&#123; return (int b) =&gt; b - a;&#125; 因为用typedef定义了一段函数类型的名字，所以可以用该名字作为返回值类型或参数类型，如： 12345Compare getFunc(int i)&#123; return (Object a,Object b)&#123; return i; &#125;;&#125; 可选参数可选参数是Dart在函数上增加的新特性，作用如名字一样，当在函数中声明了可选参数，在调用该函数时我们可以选择是否传递该可选参数。 可选参数有两种： 命名可选参数命名可选参数用大括号{}包围，默认值可用:或=来赋值。 12345678void func(int a, &#123;int b:3, c, d&#125;)&#123; //TODO&#125;//调用func(1); //(1)func(1,b:4); //(2)func(1,c:5); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用大括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用:或者=来赋值，如参数b。 在调用时，我们可以只传必须要传的参数，如(1)。如果我们想要传入某些参数，比如我们要传入参数b，则可以如(2)一样调用，注意因为是命名可选参数，所以在传入可选参数时必须声明传给哪个参数。 位置可选参数位置可选参数用方括号[]包围，默认值用=来赋值。 1234567void func(int a , [int b = 3, c, d])&#123; //TODO&#125;//调用func(1); //(1)func(1,2,3); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用中括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用=来赋值，如参数b。 表面上，位置可选参数和命名可选参数区别不大。实际上它们的区别在调用时的传参：命名可选参数传参时必须声明传给哪个参数，而位置可选参数则是按顺序来传值的。在(1)中只传必须参数时和命名可选参数一样。但在(2)中可以看到，传参时不需要声明参数名，当我们传入的参数为1、2、3时，函数将分别把参数赋值到a、b、c中。","link":"/article/dev/ca5f159a.html"},{"title":"AudioTrack播放卡顿的现象","text":"最近用AudioTrack播放PCM数据时，在某台手机上播放出现了卡顿、噪音现象。经排查，发现是设置播放的Buffer Size出问题了。 一般使用AudioTrack，会使用AudioTrack.getMinBufferSize来获取一个最小的buffer size值，用于创建AudioTrack的实例；同时，会用这个size值来创建一个byte数组的buffer，用于从文件读取数据，这个buffer的大小一般取size/4。 但是size/4有可能会得出一个不能被2整除的数字，如果用这个数字创建了一个byte数组来读取文件并传入AudioTrack，就会产生卡顿、噪音等。所以创建buffer时需要确保把size/4的值转换成可被2整除的数。","link":"/article/dev/b6a55dfb.html"},{"title":"注意Tween Animation对Activity生命周期的影响","text":"最近遇到一个神奇的问题——一个Activity调用finish()后，该页面的onStop()和onDestroy()间隔大概十秒后才被调用。 分别谷歌、百度了一下这种现象，资料很少，而且说法各不相同，都不适用于我的这种情况。后来排查了一天，终于定位到了原因：Tween Animation。 起因是，我在A页面里有一个自定义控件，这个控件通过Tween Animation实现上下翻转信息流的动画效果。如果当这个控件只有一个信息，不进行动画时，启动B页面，然后B页面调用finish()，则onStop()、onDestroy()如期执行；如果A页面的控件多于一个信息，进行动画时，启动B页面再finish()，则onStop()、onDestroy()会延迟10s左右被调用。 至于为什么Tween Animation会影响到生命周期，具体原因未知，我尝试翻看了一下View的源代码，并没有什么发现，与此比较类似的问题可以看下这篇文章：Android 坑档案：背黑锅的 Fragment。 不过，从这个问题也能引申出一些结论： 尽量使用Property Animation而非Tween Animation，Tween Animation本质是View在draw的过程中执行的，Tween Animation依赖于View的绘制、并且可能影响View的生命周期进而影响Activity；而Property Animation则不依赖View的绘制，不会对生命周期产生影响。 不要依靠Activity的onStop()、onDestroy()方法来执行回收、停止等类似的操作。说到底，onStop()、onDestroy()都是依靠底层的消息机制来通知回调的，它并不能确保每次都准时回调。所以最好的方法，是在onPause()中通过判断isFinishing()当前页面是否正在关闭。","link":"/article/dev/3e198513.html"},{"title":"The ABC of Dart Part 4 - 集合","text":"Dart中提供的集合容器分别是我们常见的List、Map、Set，但它也只有这三种类型的集合，并不像其他语言会细分到ArrayList、LinkedList之类的。 List(列表 &amp; 数组)在Dart中没有数组的概念，取而代之的是用List来代替数组的功能。 所以在List的构造函数中，有一个构造函数是传入长度来创建对象，该List对象为固定长度的列表，无法改变长度。 123456var list1 = new List();list1.length = 3;list1.length = 5;var list2 = new List(3);list2.length = 5;//error 如上，通过List()创建的列表list1可以动态更改长度，而通过List(int length)创建的列表list2则无法更改长度。 创建一个List也可以通过简略的方式实现： 1var list = [1, 2, 3]; 如上，可以通过现成数据创建List，创建方式为用中括号[]加上数据，数据之间用逗号隔开。 前面也说了，List代替了数组功能，因此它也实现了数组的功能： 123var list = [1, 2, 3];print(list[0]);//打印1list[1] = 4; 如上，可以通过使用数组的形式来调用List中的子项。 最主要的是以上几点，其他的像List的其他构造函数、其他使用方法，在源代码中的list.dart中描述得很详细了，可以对照着使用。 MapMap的初始化也和其他类相似，当然它也有简略的方式： 1234var map = &#123; \"a\": 1, \"b\": 2&#125; 如上，可以用大括号{}包住已有数据，其中的数据为一个个的键值对，每个键值对用冒号:分割，冒号前的为key，冒号后的为value。 Map的使用方式也和List相同： 1234567var map = &#123; \"a\": 1, \"b\": 2&#125;print(map[\"a\"]);map[\"b\"] = 3; 和List不同的是，中括号中的是Map里的key，而List是对应的序号。 SetSet是无序的，并且内部元素在Set中是唯一的。因此，Set无法像List一样通过序号来访问数据；还有一点，Set没有像List那样的简略的构造方式： 12var set1 = new Set();var set2 = new Set.from([1, 2, 3]); 注：from构造函数以上三个集合容器都有 要访问Set中的任意一个值，则需要通过elementAt()函数： 123var set = new Set.from([\"A\", \"B\", \"C\"]);print(set.elementAt(1));//打印B","link":"/article/dev/a2cf4cff.html"},{"title":"The ABC of Dart Part 5 - 操作符重载","text":"Dart可以像C语言一样重载部分操作符。支持重载的操作符有： &lt; + ^ [] &gt; / &amp; []= &lt;= ~/ &lt;&lt; ~ &gt;= * &gt;&gt; == – % 重载通过operator关键字实现： 123456789101112131415161718class Point&#123; int x; int y; Point(this.x, this.y); //重载加号运算符 Point operator +(Point point)&#123; return new Point(x + point.x, y + point.y); &#125;&#125;void main()&#123; Point p1 = new Point(1,2); Point p2 = new Point(3,4); print((p1 + p2).x);//打印4 print((p1 + p2).y);//打印6&#125;","link":"/article/dev/543b8039.html"},{"title":"The ABC of Dart Part 3 - 类","text":"前面说到Dart中一切皆为对象。而所有对象都是类的实例，并且所有类都为Object的子类。 和其他语言一样，类也是用class关键字作为声明。 123class TestClass&#123; ...&#125; 构造函数Dart具有构造函数，跟C++不一样，没有析构函数。 1234class TestClass&#123; TestClass()&#123; &#125;&#125; 上述代码是标准写法。如果没有显示声明构造函数，类默认有一个无参数的构造函数。另外，Dart针对构造函数中没有内容的情况时提供了一种简写，比如上述代码可以简写如下： 123class TestClass&#123; TestClass(); //简写&#125; 没有函数重载！Dart中没有函数重载功能，当在同一个类中定义了一个名为func的函数后，后面不能再定义一个名字相同、但返回类型和参数类型不同的函数。 同样的，因为没有函数重载，构造函数也不存在重载，即当一个类中定义了一个构造函数后，就无法再定义一个相同名字、但构造不同的函数。 1234567class TestClass&#123; TestClass(); TestClass(int i)&#123; //TODO &#125;&#125; 如上述代码，IDE会提示错误，不允许编译。 命名构造函数那么，如果一个类确实需要多个构造函数时该怎么做呢？Dart提供了命名构造函数，即构造函数可以定义不同的名字，通过.来实现，如： 1234567class TestClass&#123; TestClass(); //默认的构造函数 TestClass.second(int i)&#123; //自定义命名的构造函数 //TODO &#125;&#125; 通过命名构造函数，可以实现如其他语言中类的构造函数重载的功能。 生成对象生成一个类的实例对象，通过new关键字实现，如下： 12var obj1 = new TestClass(); //默认的构造函数var obj2 = new TestClass.second(1); //自定义命名的构造函数 构造函数传参Dart中的类和Java一样，通过this关键字指向实例自身，因此标准的构造函数传参和Java一致： 1234567class TestClass&#123; int param; TestClass(int param)&#123; this.param = param; &#125;&#125; 同时，Dart在传参上也提供了简写，也是通过this关键字实现的： 1234567class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2)&#123; //TODO &#125;&#125; 如上述代码，这样调用构造函数将自动把值传递给类的变量。如果构造函数只用于传递值，而不需要在里面做其他逻辑，则可以这样简写： 12345class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2);&#125; 值得一提的是，在构造函数中也可以使用可选参数来定义参数。 生成不可变的对象Dart中可以用const修饰构造函数，这样通过该构造函数构建出来的对象是不可变的对象，此类对象可以赋值给final或const修饰的常量。 12345678910111213141516class TestClass&#123; final int p1, p2; TestClass(this.p1, this.p2)&#123; //TODO &#125; const TestClass.second(this.p1, this.p2);&#125;//生成对象//const TestClass obj1 = new TestClass(1,2); //报错const TestClass obj1 = const TestClass.second(1,2); //(1)final TestClass obj2 = const TestClass.second(1,2); //(2)final TestClass obj3 = new TestClass(1,2); //(3)var obj4 = new TestClass.second(1,2); //(4) 如上，除了注释掉的那一行会报错的以外，(1)、(2)、(3)、(4)行都可以编译运行。其中，被const所修饰的常量，赋值时必须用const来生成对象，不能用new；反过来，final所修饰的对象，用const或者new来生成对象都可以。 需要注意的是，使用const修饰构造函数时，其对应的类中的所有成员变量都必须用final修饰，并且不允许有函数body（即大括号{}包裹的逻辑语句）。 同时，由于成员变量被final修饰，所以构造函数必须用简写的模式来给变量赋值。例如： 12345678class TestClass&#123; int p1; final int p2; TestClass(int a ,this.p2)&#123; p1 = a; &#125;&#125; 上述代码中，因为变量p2被修饰为final，所以必须用简写模式赋值。 Getter &amp; Setter在Dart中，类中的成员变量、成员函数不存在访问权限这个概念，像Java中的private、public之类的并不存在。 123456789class TestClass&#123; int p1; int p2;&#125;//调用var testClass = new TestClass();testClass.p1 = 1;print(testClass.p2); 如上述代码中，任何人只要生成了类的实例对象，就可以通过对象来访问、修改这个类的成员变量。但这里又和其他的语言有点不同——在Dart中，之所以可以直接调用、修改实例的变量，是因为在Dart中类的所有成员变量默认有其隐式的相同名字的Getter和Setter，如果变量被final或const修饰，那么只有Getter没有Setter。 如果要显式定义某个变量的Getter或者Setter，则分别需要用get和set关键字来实现： 123456789101112131415161718192021222324252627class TestClass&#123; int p1; int p2; //int get p1 =&gt; p1;//报错 //set p1(int i) =&gt; p1 = i;//报错 int get myP1 =&gt; p1; int get myP2&#123; return p2; &#125; set myP1(int i) =&gt; p1 = i; set myP2(int i)&#123; p2 = i; &#125;&#125;//调用var testClass = new TestClass();testClass.myP1 = 1; //调用Setter方法myP1testClass.myP2 = 2; //调用Setter方法myP2print(testClass.myP1); //调用Getter方法myP1，打印1print(testClass.myP2); //调用Getter方法myP2，打印2 如上述代码，Getter和Setter的方法名可以相同。注意get修饰的Getter方法不能有()。set修饰的Setter方法后面带有()，但调用时不能用testClass.myP1(1)这种方式，而是用=来调用Setter方法。 前面说到，每个成员变量有其隐式的Getter和Setter，所以当我们自定义Getter、Setter时，命名不能用和成员变量一样的名字。 extends &amp; implements类的继承通过extends关键字来实现，基本实现和操作跟Java大致相同。 12345678910111213141516class BaseClass&#123; void func1()&#123; //TODO &#125; void func2()&#123; //TODO &#125;&#125;class TestClass extends BaseClass&#123; @override void func1()&#123; super.func1(); &#125;&#125; 如上，TestClass集成了BaseClass，因此可以选择性地改写BaseClass的方法。 而实现接口则通过implements关键字实现，与Java不同的是dart没有interface这个关键字，因为每一个类都是一个隐式接口。以上面的BaseClass为例： 123456789class TestClass2 implements BaseClass&#123; @override void func1()&#123; &#125; @override void func2()&#123; &#125;&#125; TestClass2通过implements实现了BaseClass内定义的方法func1()、func2()，虽然BaseClass在func1()、func2()里都有定义内容，但通过implements实现后，TestClass2并不会像extends一样默认执行BaseClass的方法。 抽象类抽象类通过abstract关键字修饰类： 123456789101112131415abstract class BaseClass&#123; void func();&#125;class TestClass extends BaseClass&#123; @override void func()&#123; &#125;&#125;class TestClass2 implements BaseClass&#123; @override void func()&#123; &#125;&#125; 可以看出，抽象类在继承和实现接口上并没有什么区别，都是强制要求实现抽象类中定义的函数。 和Java不同，dart只有抽象类，没有抽象方法。 mixin(混合)我们知道，实现接口时可以implements多个接口，每个接口用逗号隔开： 123class TestClass implements BaseClass1,BaseClass2&#123; ...&#125; 而继承只能继承一个类。某些时候，可能我们希望能继承多个类，不同的方法用不同类的实现方式——这时候，就可以使用dart提供的mixin(混合)模式。 mixin通过with关键字来实现。举个例子，现在分别有两个类ClassA和ClassB，通过这两个类组合成一个新的类ClassC，则表现为： ClassC = ClassA with ClassB 假设ClassA中所有方法的集合为\\(F_{A}\\)，ClassB中所有方法的集合为\\(F_{B}\\)，ClassC中所有方法的集合为\\(F_{C}\\)，则可理解为： $$F_{C}=F_{B} \\cup (F_{A}-F_{B})$$ 即ClassC中的所有方法为ClassA和ClassB的方法的集合，如果ClassA和ClassB中有重复的方法，则取ClassB的实现： 1234567891011121314151617181920212223class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125;&#125;class ClassC = ClassA with ClassB;void main()&#123; ClassC classC = new ClassC(); classC.func1();//输出ClassB func1 classC.func2();//输出ClassA func2&#125; with关键字也可以通过逗号混合多个类。例如，目前分别有ClassA、ClassB、ClassC三个类，将该三个类组合成一个新类ClassD： ClassD = ClassA with ClassB,ClassC 这就相当于按顺序调用with： ClassD = (ClassA with ClassB) with ClassC 例子如下： 1234567891011121314151617181920212223242526272829303132333435363738class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125; void func3()&#123; print(\"ClassA func3\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125; void func2()&#123; print(\"ClassB func2\"); &#125;&#125;class ClassC&#123; void func1()&#123; print(\"ClassC func1\"); &#125;&#125;class ClassD = ClassA with ClassB,ClassC;void main()&#123; ClassD classD = new ClassD(); classD.func1();//输出ClassC func1 classD.func2();//输出ClassB func2 classD.func3();//输出ClassA func3&#125; 工厂构造函数使用factory修饰构造函数，具体意义不多说了，网上给出的例子都是方便调用者可以使用同一个对象，并不是单纯意义上的工厂设计模式。","link":"/article/dev/bd58250c.html"},{"title":"The ABC of Dart Part 6 - 库类的引用","text":"Dart中除了最基本的类型对象外，还提供了很多不同功能的库或类，比如一些异步操作、IO操作等等，这些都被一一封装到Dart的SDK中，由一个个独立的.dart文件承载着。 举个例子，在Java中，如果要使用某个类的功能，需要先通过import把该类引用进来。同样的，Dart也需要这种操作。 目前我使用的Android Studio 3.1.3，比较不好的一点是写Dart时不能像Java一样自动引用对应的库。 Pub包管理器了解库类的引用前，先学习一下Dart中的Pub包管理器。 Pub有点像Android项目中的Gradle——Gradle管理下的Android项目，我们用build.gradle来管理项目中的引用和其他配置；同样的，Dart也有pubspec.yaml来管理引用。 一般地，一个Dart项目的根目录下，包含有lib文件夹和pubspec.yaml文件。该文件包含了一个包的元数据，例如包的名称等。所以一个Dart项目也是一个包。 举个例子，一个最简单的pubspec.yaml内容如下： 1234name: testdeppendencies: cupertino_icons: ^0.1.2 name表示该包的名称，而deppendencies下的每一项则表示该包的引用。上述内容就表示了一个名叫test的包，这个包引用了一个名为cupertino_icons，版本号为0.1.2的包。 这里的版本号写法为^0.1.2，表示该版本号的约束为&gt;=0.1.2 &lt;0.2.0，这种写法为Caret语法，关于这点不作详细描述。 关于更多的有关pub的操作（例如配置项目资源、使用pub的命令行命令等）就不再阐述，此类操作可以等需要用到时再查找。 importDart中的import用法和Java基本相同，不同的是import后缀的引用路径： 1234567891011121314//\"dart:\"前缀表示Dart的标准库import 'dart:async';//同文件夹下的dartimport 'lib1.dart';//同路径下的其他文件中的dartimport 'lib2/lib2.dart';//绝对路径import '../lib3/lib3.dart';//通过包名+路径import 'package:test/lib1.dart'; 其中通过包命+路径的引用方式，结合上述的Pub，可知我在本项目中的pubspec.yaml里引用了一个名为test的包，则我可以在项目内的.dart文件里通过前缀package:加上包名+库类在该包内的路径来引用相应的库类。 命名冲突很多时候，我们引用的库类可能存在名称相同的情况，比如： 12345import 'p1/lib1.dart';import 'p2/lib2.dart';//编译器提示异常MyClass myClass = new MyClass(); 如上，我在lib1.dart和lib2.dart中都定义了一个名为MyClass的类，当我在引用处使用MyClass时，编译器提示我这个类在lib1.dart和lib2.dart都有定义，因此无法编译。 针对这种情况，可以使用as关键字，对某个引用声明其命名空间： 12345import 'p1/lib1.dart' as lib1;import 'p2/lib2.dart' as lib2;lib1.MyClass myClass1 = new lib1.MyClass();lib2.MyClass myClass2 = new lib2.MyClass(); 如上，通过声明不同的命名空间，则可以在调用时通过对应的命名空间即可。 部分引用有时候，我们可能只希望引用一个.dart文件中的某些库类，而不是引用其全部内容，则可以通过关键字show和hide来实现。 顾名思义，show表示只引用一个文件中的指定类；而hide则表示除指定类外其他类都引用。它们都可以通过逗号指定多个类： 12import 'p1/lib1.dart' show MyClass1,MyClass2;import 'p2/lib2.dart' hide MyClass3; librarylibrary关键字可以定义一个.dart文件（即一个库）的名字，但不影响库的引用，因为引用都是通过文件路径。 之所以要定义名字，是因为这个要配合part、part of关键字来使用。 例如，当我要维护一个库math，这个库包含项目需要的所有数学方法，比如加减乘除，那么这个库可以通过part来将不同的功能放到不同的.dart文件中，达到将库分散、细化粒度的效果。 123456library math;part 'plus.dart';part 'minus.dart';part 'multiply.dart';part 'divide.part'; 如上，我可以创建一个math.dart文件，这个文件路径在lib/math文件夹下。math.dart文件内部只有上述内容，因为具体实现功能都分散给各.dart文件来实现。 相应地，part修饰的各个文件内部，都需要通过part of来声明自身属于哪个库： 1part of math; 所以在plus.dart等四个文件中，开头都需要通过上述代码声明自己属于math这个库中。 关于library、part、part of，可以再看看Dart的SDK，里面的很多库都是通过这种方式实现的。 exportexport的使用方式和import相同，但是意义却不一样。它表示在一个库中导出另一个库，这样当第三个库引用第一个库时，也能引用到第二个库的内容。 例如，我现在有lib1.dart、lib2.dart、lib3.dart三个文件，其中lib1.dart中的内容为： 12import 'lib2.dart';export 'lib2.dart'; 然后在lib3.dart中： 1import 'lib1.dart'; 这样，即使lib3.dart中没有导入lib2.dart，也可以用到lib2.dart内的内容。 关于export的实际应用可以看一下这篇文章：organizing-a-library-package。","link":"/article/dev/cd32d183.html"},{"title":"RecyclerView重写ItemAnimator导致的Bug","text":"最近有一个需求，用一个八宫格显示图片，后台不断发送图片过来，每个格子的图片定时刷新，同时做渐变切换的效果。 同事用RecyclerView+自定义渐变效果的ItemAnimator实现这个效果，具体来说就是每次要切换图片时，调用notifyItemChanged()对应的格子。 但是效果不如预期，经常会出现前一张图片没有完全变成0透明度，导致两张图片看起来像是透明叠加在一起。 这里简单说一下RecyclerView的局部刷新逻辑：当调用notifyItemChanged()时，会先从内部的缓存池找change类型的缓存ViewHolder（缓存池会保存很多类型的ViewHolder），如果没有，会调用Adapter的onCreateViewHolder()创建一个新的ViewHolder，然后将新的ViewHolder和原来对应的局部的ViewHolder传入ItemAnimator中的animateChange()方法，在这个方法内对新旧Holder执行相应动画，同时将新的Holder传入Adapter的onBindViewHolder方法中，最后RecyclerView将新的Holder替换旧的Holder，旧的Holder则存入缓存池中对应change类型的缓存里。 后来通过测试证实，如果调用notifyItemChanged()较慢时，通过打印可以看到，就是两个不同的ViewHolder实例在不断的互相替换；但是如果调用速度过快，后面就会变成新、旧Holder都是同一个Holder，导致动画异常。 事实上，在源码默认的DefaultItemAnimator中，可以看到在animateChange()方法里有判断新旧Holder是否一致，若一致则调用animateMove()方法；而自定义的ItemAnimator则没有实现该功能。 虽然最后的解决方法是不用ItemAnimator，而改用TransitionDrawable来实现效果。但需要注意的是，如果往后需要使用ItemAnimator，最好在DefaultItemAnimator的基础上改，因为这东西坑还是蛮多的，一个完整的ItemAnimator要写的代码也不少。","link":"/article/dev/9d9111ff.html"},{"title":"The ABC of Dart Part 7 - 异步","text":"Dart中没有线程这种概念，或者说对线程进行了包装，调用者无法对线程进行直接的操作。所以Dart为异步操作提供了一些对应的API和关键字，分别有： async和await关键字 Async*、sync*、yield*关键字和Stream的API Future的API 细分下来还是挺多内容的，尤其像Stream这种流式操作，网上相关的资料都叙述得不够详细。 async和awaitasync和await组合可以实现异步功能，并且使得代码看上去像是同步流程一样（网上说的）。 首先举个例子： 12345678import 'dart:io';import 'dart:core';void main() &#123; print(new DateTime.now());// (1) sleep(new Duration(seconds: 1)); print(new DateTime.now());// (2)&#125; 如上，最终会先打印(1)，间隔1秒后打印(2)，打印如下： 122018-08-13 15:40:13.5852712018-08-13 15:40:14.588507 其中DateTime来自包dart:core，而sleep方法来自包date:io。 我们暂且把main()函数运行的环境称为“线程”。当调用sleep时，Dart的主线程会被阻塞，直到sleep结束才接着进行下一步操作，这些现象都跟其他语言相同。 但是我们可以通过将耗时操作异步执行，达到不阻塞主线程： 1234567891011121314import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印结果： 1234main start:2018-08-13 17:28:31.456818main end:2018-08-13 17:28:31.462557async start:2018-08-13 17:28:31.462995async end:2018-08-13 17:28:32.463558 可以看到，主线程并没有被阻塞，异步操作则被sleep阻塞，但不会影响到主线程。 从上述代码中可以看出，async关键字用于修饰函数。当一个函数被async修饰时，该函数将返回一个future对象。被async修饰的函数，被调用时将运行在异步环境。 async可以单独使用（修饰函数），但await则不行。await用于修饰返回future的函数，并且必须在带有async的函数内使用，它的作用为等待一个异步函数执行完毕。 例如，我有如下代码： 1234567891011121314151617181920import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); callSleep2(); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;callSleep2() async &#123; print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下： 123456main start:2018-08-13 18:22:04.529513main end:2018-08-13 18:22:04.534770async start:2018-08-13 18:22:04.535263async end:2018-08-13 18:22:04.535454callSleep2 start:2018-08-13 18:22:04.537200callSleep2 start:2018-08-13 18:22:05.537942 可以看到callSleep2是在callSleep运行之后才运行的。如果在callSleep中对callSleep2加入await： 1234567891011121314151617181920import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); await callSleep2(); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;callSleep2() async &#123; print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下： 123456main start:2018-08-13 18:23:16.099116main end:2018-08-13 18:23:16.104197async start:2018-08-13 18:23:16.104623callSleep2 start:2018-08-13 18:23:16.106389callSleep2 start:2018-08-13 18:23:17.106978async end:2018-08-13 18:23:17.108346 可以看出打印不同了。callSleep需要等到callSleep2的异步执行完毕之后才能继续执行。 Future API事实上，Dart中的异步执行操作都是依靠Future来实现的，即便是上述的async和await关键字，最终操作的依然是Future。 Future所代表的含义，就是在调用时调用本身立即返回，并在稍后的某个时候执行完成时再获得返回结果。 Future的定义在SDK的async包中，可以看出有好几种构造函数： Future(FutureOr computation()) Future.microtask(FutureOr computation()) Future.sync(FutureOr computation()) Future.value([FutureOr value]) Future.error(Object error, [StackTrace stackTrace]) Future.delayed(Duration duration, [FutureOr computation()]) 其中最常用的构造函数是1和6。事实上，如果接触过RxJava，对于Future的使用方式会容易理解一些，因为基本的构造、链式调用等一系列方法都非常相似。 例如： 12345678910111213141516import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) =&gt; print(\"future end:$i, time:$&#123;new DateTime.now()&#125;\")); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下：1234main start:2018-08-16 15:31:15.543445main end:2018-08-16 15:31:15.550062future start:1, time:2018-08-16 15:31:15.551202future end:2, time:2018-08-16 15:31:16.554641 Future(FutureOr&lt;T&gt; computation())这个构造函数相当于RxJava中的Observable.create()方法，将需要异步执行的操作包裹在函数，将该函数作为参数传递给Future。 Future在main()外初始化时不会立即执行，直到被main()调用时则开始执行，这一点和RxJava不同，RxJava必须调用subscribe()才开始调用。 如果需要在Future执行完毕后获取异步执行的结果来进行一些操作，可以使用then()来执行，这一点跟RxJava的subscribe()操作相同。 同时，then具有可选参数Function onError，可以用来处理Future在执行过程中出现异常的情况。 123456789101112131415161718import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); throw new ArgumentError(\"Custom Error\"); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) =&gt; print(\"future end:$i, time:$&#123;new DateTime.now()&#125;\"), onError: (e) =&gt; print(\"catch error:$e\")); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印： 1234main start:2018-08-16 15:41:03.173648main end:2018-08-16 15:41:03.180109future start:1, time:2018-08-16 15:41:03.181231catch error:Invalid argument(s): Custom Error 可以看到，如果Future内部出现了异常，将不会返回结果到then()中的第一个函数，而是将异常返回给第二个onError函数。 then()的链式调用有时候我们可能需要在Future之后执行多步操作，并且每一步操作都依赖于上一步的结果。对此我们当然可以把相关操作写在同一个then()里面。但是Dart提供了对应的链式调用，使得我们可以用多个then()将不同的操作串联起来： 12345678910111213141516171819202122232425import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) &#123; print(\"first then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;).then((i) &#123; print(\"second then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;).then((i) &#123; print(\"third then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印： 123456main start:2018-08-16 15:53:53.024344main end:2018-08-16 15:53:53.030724future start:1, time:2018-08-16 15:53:53.031873first then:2, time:2018-08-16 15:53:54.034334second then:3, time:2018-08-16 15:53:54.034514third then:4, time:2018-08-16 15:53:54.034651 我们在then()操作中可以将结果返回给下一个then()，并且参数类型不限定于Future返回的类型。 Future还有许多API，可以配合链式调用随意组合，具体的就不细说了。 函数生成器函数生成器是指利用惰性函数计算结果序列，以提升性能。就我的理解而言，类似于在函数内生成一个闭包，然后可以经过循环得到一系列结果，但结果并不是一次性返回，而是像一段数据流一样每次返回一个结果。 具体使用场景，自己还没想到，也许在一些需要递归或者循环调用返回的场景能用到吧。 同步生成器sync*使用sync*修饰函数时，函数将自动返回一个Iterable类型的实例，并可以根据该实例获取Iterator类型的迭代器。通过迭代器的函数moveNext()判断是否存在下一个值，通过current获取下一个值。 12345678910111213141516171819Iterable syncGenerator(int i) sync* &#123; print(\"syncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; print(\"syncGenerator yield\"); yield value; &#125; print(\"syncGenerator end\");&#125;void main() &#123; Iterator iterator = syncGenerator(3).iterator; print(\"start\"); while (iterator.moveNext()) &#123; print(\"start while\"); print(iterator.current); print(\"end while\"); &#125; print(\"end\");&#125; 如上，使用sync*制作生成器时，函数的内部需要通过yield关键字来声明需要输出的结果。yield表示生成，其实际操作类似于return，可用于声明结果或者是表达式。 上述输出如下： 12345678910111213141516startsyncGenerator startsyncGenerator yieldstart while0end whilesyncGenerator yieldstart while1end whilesyncGenerator yieldstart while2end whilesyncGenerator endend 可以看出，当调用生成器syncGenerator()时，生成器内部并未开始执行，直到调用moveNext()函数时，生成器开始运行，并进入循环，直到遇到yield所在行后，将在此暂停，并将结果返回到外部，注意此时生成器的内部环境依然保存着不变；当外部再次调用moveNext()时，生成器将由暂停变为继续运行，直到内部满足条件，不再运行到yield所在行，生成器运行结束。 当然，由于同步生成器返回的是Iterable，所以可以使用Dart提供的API进行链式调用： 1234567891011Iterable syncGenerator(int i) sync* &#123; print(\"syncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"syncGenerator end\");&#125;void main() &#123; syncGenerator(3).forEach((i) =&gt; print(i));&#125; 打印如下： 12345syncGenerator start012syncGenerator end 异步生成器async*异步生成器的原理和同步生成器基本相同，不同的是由于异步生成器运行在异步环境，因此返回的不是Iterable而是Stream。因此这里涉及到了Stream的相关操作和API。 Stream APIStream表示一个数据的流，关于流的概念和其他语言里的流的理解基本相同（比如Java8中的Stream），这里引用一下Java中对Stream的定义： Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。 12345678910111213Stream asyncGenerator(int i) async* &#123; print(\"asyncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"asyncGenerator end\");&#125;void main() &#123; print(\"start\"); asyncGenerator(3).listen((i) =&gt; print(i)); print(\"end\");&#125; 打印如下： 1234567startendasyncGenerator start012asyncGenerator end 可以看到由于异步执行，生成器的输出在main()执行完后才执行。 listen()方法相当于RxJava中的subscribe()方法，目的都是添加响应数据的方法，并且都会返回一个可以控制流的对象。通过listen()返回的控制对象类型为StreamSubscription。通过StreamSubscription可以方便地操控流： 1234567891011121314151617181920Stream asyncGenerator(int i) async* &#123; print(\"asyncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"asyncGenerator end\");&#125;void main() &#123; print(\"start\"); StreamSubscription subscription = asyncGenerator(3).listen( null, onDone: () =&gt; print(\"done\")); subscription.onData((i) &#123; print(i); if (i &gt;= 1) &#123; subscription.cancel().then((f) =&gt; print(\"cancel\")); &#125; &#125;); print(\"end\");&#125; 打印： 123456startendasyncGenerator start01cancel 可以看到cancel()操作会将异步生成器中断，不会使其运行到最后一步。","link":"/article/dev/ba35e115.html"},{"title":"Flutter先导篇","text":"Flutter使用Dart作为开发语言，在开发理念上也是偏向于网页开发的（虽然我没开发过网页）。 应用的基础构成Flutter的执行起点为main()函数，然后通过runApp()方法启动页面。 目前Flutter提供了两个App类，分别为安卓风格的MaterialApp和IOS风格的CupertinoApp，一般runApp()函数都是传入这两个App类的实例。 App类有点像Android中的Application，但它承载了更多的功能，比如设置应用主题、应用在后台列表中的颜色、名称等。值得一提的是，App类也属于Widget，所以按Widget的理念去理解即可。 通过App类的home参数，我们传入一个Widget，即表示我们在Flutter的首页所显示的内容就是该Widget。一般而言，我们会传入Scaffold作为App类的home。在Flutter中，每个页面都由Scaffold构成（或者说承载），类似于Android中的Activity。Scaffold中可以设置一个页面的app bar、bottom sheet等，其中最主要的是widget类型的body参数，可以理解为类似HTML中的&lt;body&gt;标签，此处显示的就是当前页面的本体。 所以一个Flutter的启动链条，就是： main.dart –&gt; main() –&gt; 调用runApp() –&gt; 生成App类 –&gt; home参数传入生成的Scaffold实例 –&gt; body参数传入自己实现的页面(widget) 页面跳转要在Flutter中跳转到另一个页面，则需要通过路由Navigator实现。 在Android中也有页面路由的概念，但是一般是自己实现的。Navigator更类似于后台维护一个页面的栈（或一个map）。 上面说到，每个页面都由Scaffold承载。而为了使用Navigator，需要在新页面的外层封装一个PageRoute，这个PageRoute类似于我们使用容器去保存一些数据时，为了方便管理、设置不同属性，会为数据提供一个包装类Wrapper一样。在不同的App下有不同的PageRoute，比如在Material下就用MaterialPageRoute。 当我们要跳转到第二个页面时，只需要调用Navigator.push()方法即可，其内部会记录各页面之前的跳转顺序，所以我们按Back键回退时，会自动回到第一个页面。 轻量化Widget在Android中，创建一个控件代价不算大，但如果我们要刷新一个控件，我们更倾向于对控件的参数、内容进行更改，而不是删除再重新创建一个。 Flutter引入了万物皆Widget的概念，即所有的内容都是一层控件。 Flutter对Widget的创建开销很小，而且会在其重新创建时与旧的Widget进行比较，仅对差异部分进行重绘。所以Flutter和Android原生的开发理念不同——Android依然遵循着万物皆对象的概念，其控件相对之下显得略“重”，鼓励我们复用、刷新控件来达到数据更新显示；而Flutter鼓励我们在数据更新时直接重建Widget，不需要考虑new一个Widget的开销问题。 State和StatefulWidgetFlutter的Widget分为两种：StatelessWidget和StatefulWidget，前者表示不会变更的控件，比如一段不会变的文字、图标等；后者表示其会根据数据、事件动态刷新变更，所以它需要配合State一起使用。 State和StatefulWidget相互绑定在一起。创建StatefulWidget时，将调用createState()创建其指定的State。其指定的State只会创建一次，内部变量会一直在Widget Tree销毁前保存着。setState()函数只会让State重新build其绑定的Widget，不会再创建State。 Parent Widget和Child Widget之间的通信按照Flutter的官方说法，Child Widget通过监听函数(callback)向上通知Parent Widget，Parent Widget通过监听函数收到通知后，调用setState()方法改变数据状态，然后重新创建Child Widget。 简单，粗暴，一切归于重建，遇事不决，先重建Widget再说。","link":"/article/dev/b35ace79.html"},{"title":"RxJava的一些线程问题","text":"RxJava上提供了一系列的线程池，用起来确实很方便，不过随便用的话很容易遇到坑。 坑1：Schedulers.computation()Schedulers.computation()在RxJava中定义为用于计算任务的线程池，其线程数等于当前运行环境的CPU核心数。比如在我的华为Mate9 Pro中，其线程数为8。 事实上RxJava中很多操作符都默认使用computation()线程池，比如timer()、interval()、intervalRange()等。 最近有同事跟我说，使用timer()、interval()的时候，有几率不执行。其实根本原因是其他地方也使用了computation()中的线程，并且其线程池中的所有线程都被占用了，必须等到computation()中有空闲的线程后才执行后面的任务。 所以使用到默认computation()线程的操作符时，最好直接设置io()或者newThread()线程。 坑2：Schedulers.trampoline()Schedulers.trampoline()在RxJava中定义为在当前线程中执行，如果同时存在多个任务，则根据FIFO原则执行任务。 上面说到有同事遇到timer()不执行的情况，所以他实际操作的时候使用这种写法： 123456Observable.timer(5, TimeUnit.MINUTES, Schedulers.trampoline()) .subscribeOn(Schedulers.io()) .observerOn(AndroidSchedulers.mainThread()) .subscribe(() -&gt; &#123; //TODO &#125;); 同时由于项目中设置了RxJavaPlugins.setErrorHandler()，所以一开始执行没什么问题。后来我去掉了这个设置之后，就开始频繁崩溃了： 123456789101112131415161718192021222324252627282930313233343536io.reactivex.exceptions.UndeliverableException: java.lang.InterruptedExceptionat io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:349)at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:64)at io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:38)at io.reactivex.Observable.subscribe(Observable.java:11040)at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)at java.util.concurrent.FutureTask.run(FutureTask.java:266)at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)at java.lang.Thread.run(Thread.java:764)Caused by: java.lang.InterruptedExceptionat java.lang.Thread.sleep(Native Method)at java.lang.Thread.sleep(Thread.java:373)at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:395)at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:60)... 11 morejava.lang.InterruptedExceptionat java.lang.Thread.sleep(Native Method)at java.lang.Thread.sleep(Thread.java:373)at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:395)at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:60)at io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:38)at io.reactivex.Observable.subscribe(Observable.java:11040)at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)at java.util.concurrent.FutureTask.run(FutureTask.java:266)at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)at java.lang.Thread.run(Thread.java:764) 要理解为什么会崩溃，首先要从timer()的实现去入手： 123456public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit, Scheduler scheduler) &#123; ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); return RxJavaPlugins.onAssembly(new ObservableTimer(Math.max(delay, 0L), unit, scheduler)); &#125; 其实现为ObservableTimer，只需要看其中的subscribeActual()方法实现即可： 123456789@Overridepublic void subscribeActual(Observer&lt;? super Long&gt; s) &#123; TimerObserver ios = new TimerObserver(s); s.onSubscribe(ios); Disposable d = scheduler.scheduleDirect(ios, delay, unit); ios.setResource(d);&#125; 可以看到，其实现为调用传入的Scheduler的scheduleDirect()方法。上面代码中传入的为Schedulers.trampoline()，其scheduleDirect()的实现： 12345678910public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; try &#123; unit.sleep(delay); RxJavaPlugins.onSchedule(run).run(); &#125; catch (InterruptedException ex) &#123; Thread.currentThread().interrupt(); RxJavaPlugins.onError(ex); &#125; return EmptyDisposable.INSTANCE;&#125; 上面的代码表示当timer()传入Schedulers.trampoline()时，其延时效果通过当前线程的sleep()实现。 作为对比，看一下Schedulers.computation()的scheduleDirect()实现： 1234public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; PoolWorker继承了NewThreadWorker，其scheduleDirect()的实现为： 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 代码里的executor为线程池的实例，所以当timer()传入Schedulers.computation()时，其延时效果通过线程池的任务计划调度执行。 再回头看出现的崩溃，经试验，其崩溃的时机在于timer()还未执行，然后手动调用dispose()取消其执行时出现的。所以还需要看下dispose()的具体实现，其被调用时实际是调用ScheduledRunnable的dispose()方法： 1234567891011121314151617181920212223242526public void dispose() &#123; for (;;) &#123; Object o = get(FUTURE_INDEX); if (o == DONE || o == SYNC_DISPOSED || o == ASYNC_DISPOSED) &#123; break; &#125; boolean async = get(THREAD_INDEX) != Thread.currentThread(); if (compareAndSet(FUTURE_INDEX, o, async ? ASYNC_DISPOSED : SYNC_DISPOSED)) &#123; if (o != null) &#123; ((Future&lt;?&gt;)o).cancel(async); &#125; break; &#125; &#125; for (;;) &#123; Object o = get(PARENT_INDEX); if (o == DONE || o == PARENT_DISPOSED || o == null) &#123; return; &#125; if (compareAndSet(PARENT_INDEX, o, PARENT_DISPOSED)) &#123; ((DisposableContainer)o).delete(this); return; &#125; &#125;&#125; 即最终的实现是通过调用线程池中对应任务的Future的cancel()方法，在当前例子中其cancel()方法传入的为true，即会执行中断线程的操作。 回到开头的例子，在传入Schedulers.trampoline()后，又通过subscribeOn()将任务放入Schdulers.io()的线程中执行，即其在io()线程中调用了sleep()方法。紧接着在调用dispose()方法时，将当前io()线程的Future取出并执行cancel(true)。如果当前线程中正在sleep()，则会直接抛出InterruptedException异常来中断操作。而在trampoline()的内部实现中，InterruptedException不会被截获到原来的Observable的onError中，而是直接抛到RxJavaPlugins的onError()中处理，所以在取消设置RxJavaPlugins.setErrorHandler()后，就会出现崩溃。 总结 使用默认computation()线程池实现的操作符时，最后另外设置线程进去。 尽量不要使用trampoline()来实现延时操作 日常开发时不要设置RxJavaPlugins.setErrorHandler() 线上正式包中最好设置RxJavaPlugins.setErrorHandler()","link":"/article/dev/64bbb612.html"},{"title":"MediaCodec编码摄像头数据时控制帧率的方法","text":"控制帧率一般而言，使用MediaCodec配合OpenGLES编码摄像头数据是常规做法。如果要限制帧率，最简单的方法是限制OpenGLES的绘制间隔时间。 假设使用GLSurfaceView进行绘制，设置RenderMode为RENDERMODE_WHEN_DIRTY，在SurfaceTexture监听onFrameAvailable()来通知GLSurfaceView绘制时，一般手机能达到60FPS。 按照上面的说法，例如要限制到30FPS，只需要在onFrameAvailable()或者onDrawFrame()中加入sleep()，每次绘制后睡眠一定时间，这样预览画面和实际编码出来的MP4将会是同样的30FPS。 注：使用Camera设定预览帧率貌似不起作用，起码在我的华为Mate9 Pro上没有效果。 但是，我希望可以做到预览画面帧率不变，编码时限制FPS，就需要额外启动线程来处理。 由于MediaCodec中使用InputSurface编码数据时需要运行在GL线程，一般的做法都是额外启动线程-&gt;初始化EGL环境-&gt;编码。在这基础上，只要我们限制通知MediaCodec编码的频率，就可以限制编码出来的数据的FPS。 下面是自己demo中的部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic void onDrawFrame(GL10 gl) &#123; if (!mMediaRecorder.isInit()) &#123; mMediaRecorder.setEglContext(EGL14.eglGetCurrentContext()); mMediaRecorder.setTextureId(mCameraDrawable.getTextureId()); mMediaRecorder.init(); &#125; if (!mMediaRecorder.isStart()) &#123; mMediaRecorder.startRecord(); new Thread() &#123; @Override public void run() &#123; int fps = 20; long fpsTime = 1000 / fps; long time = System.currentTimeMillis(); long diffTime = 0; while (true) &#123; LogUtils.i(\"start\"); final SurfaceTexture surfaceTexture = mCameraDrawable.getSurfaceTexture(); surfaceTexture.getTransformMatrix(mTextureMartix); mMediaRecorder.record(surfaceTexture.getTimestamp(), mTextureMartix); diffTime = System.currentTimeMillis() - time; if (diffTime &lt; fpsTime) &#123; try &#123; sleep(fpsTime - diffTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if(!mMediaRecorder.isStart())&#123; break; &#125; time = System.currentTimeMillis(); &#125; &#125; &#125;.start(); &#125; mCameraDrawable.draw(); mFpsPrinter.printFPS();&#125; 上述代码中新起的线程就是控制MediaCodec编码频率的。值得一提的是，MediaCodec使用InputSurface编码时，都是需要通过SurfaceTexture来获取每一帧的时间戳。过去我曾经陷入过迷思，不知道如何控制时间戳来控制帧率。后来想想，其实在编译每一帧时获取其对应的时间戳即可。 编码时加速、减速视频假设我们想保持帧率不变，但是实际编码出来的MP4是加速或减速过的视频，可以通过修改上面提到的时间戳效果。比如，将输入的SurfaceTexture.getTimestamp()乘以2，再传递给EGLExt.eglPresentationTimeANDROID()，最终的效果就是整个视频是加快一倍的；减速同理，除以指定系数即可。","link":"/article/dev/c04b6b0b.html"},{"title":"The ABC of Dart Part 8 - 并发","text":"说到Dart中的并发，这里需要先介绍一下Dart中的异步机制，以下内容转自Dart异步任务与消息循环机制 Dart与消息循环机制翻译自https://www.dartlang.org/articles/event-loop/ 异步任务在Dart中随处可见，例如许多库的方法调用都会返回Future对象来实现异步处理，我们也可以注册Handler来响应一些事件，如：鼠标点击事件，I/O流结束和定时器到期。 这篇文章主要介绍了Dart中与异步任务相关的消息循环机制，阅读完这篇文章后相信你可写出更赞的异步执行代码。你也能学习到如何调度Future任务并且预测他们的执行顺序。 在阅读这篇文章之前，你最好先要了解一下基本的Future用法。 基本概念如果你写过一些关于UI的代码，你就应该熟悉消息循环和消息队列。有了他们才能保重UI的绘制操作和一些UI事件，如鼠标点击事件可以被一个一个的执行从而保证UI和UI事件的统一性。 消息循环和消息队列一个消息循环的职责就是不断从消息队列中取出消息并处理他们直到消息队列为空。 消息队列中的消息可能来自用户输入，文件I/O消息，定时器等。例如下图的消息队列就包含了定时器消息和用户输入消息。 上述的这些概念你可能已经驾轻就熟了，那接下来我们就讨论一下这些概念在Dart中是怎么表现的？ Dart的单线程执行当一个Dart的方法开始执行时，他会一直执行直至达到这个方法的退出点。换句话说Dart的方法是不会被其他Dart代码打断的。 Note:一个Dart的命令行应用可以通过创建isolates来达到并行运行的目的。isolates之间不会共享内存，它们就像几个运行在不同进程中的app，中能通过传递message来进行交流。出了明确指出运行在额外的isolates或者workers中的代码外，所有的应用代码都是运行在应用的main isolate中。要了解更多相关内容，可以查看https://www.dartlang.org/articles/event-loop/#use-isolates-or-workers-if-necessary 正如下图所示，当一个Dart应用开始的标志是它的main isolate执行了main方法。当main方法退出后，main isolate的线程就会去逐一处理消息队列中的消息。 事实上，上图是经过简化的流程。 Dart的消息循环和消息队列一个Dart应用有一个消息循环和两个消息队列– event队列和microtask队列。 event队列包含所有外来的事件：I/O，mouse events，drawing events，timers，isolate之间的message等。 microtask 队列在Dart中是必要的，因为有时候事件处理想要在稍后完成一些任务但又希望是在执行下一个事件消息之前。 event队列包含Dart和来自系统其它位置的事件。但microtask队列只包含来自当前isolate的内部代码。 正如下面的流程图，当main方法退出后，event循环就开始它的工作。首先它会以FIFO的顺序执行micro task，当所有micro task执行完后它会从event 队列中取事件并执行。如此反复，直到两个队列都为空。 注意：当事件循环正在处理micro task的时候。event队列会被堵塞。这时候app就无法进行UI绘制，响应鼠标事件和I/O等事件 虽然你可以预测任务执行的顺序，但你无法准确的预测到事件循环何时会处理你期望的任务。例如当你创建一个延时1s的任务，但在排在你之前的任务结束前事件循环是不会处理这个延时任务的，也就是或任务执行可能是大于1s的。 通过链接的方式指定任务顺序如果你的代码之间存在依赖，那么尽量让他们之间的依赖关系明确一点。明确的依赖关系可以很好的帮助其他开发者理解你的代码，并且可以让你的代码更稳定也更容易重构。 先来看看下面这段错误代码： 123// 这样写错误的原因就是没有明确体现出设置变量和使用变量之间的依赖关系future.then(...set an important variable...);Timer.run(() &#123;...use the important variable...&#125;); 正确的写法应该是： 123// 明确表现出了后者依赖前者设置的变量值future.then(...set an important variable...) .then((_) &#123;...use the important variable...&#125;); 为了表示明确的前后依赖关系，我们可以使用then()()来表明要使用变量就必须要等设置完这个变量。这里可以使用whenComplete()来代替then，它与then的不同点在于哪怕设置变量出现了异常也会被调用到。这个有点像java中的finally。 如果上面这个使用变量也要花费一段时间，那么可以考虑将其放入一个新的Future中： 12future.then(...set an important variable...) .then((_) &#123;new Future(() &#123;...use the important variable...&#125;)&#125;); 使用一个新的Future可以给事件循环一个机会先去处理列队中的其他事件。 怎么安排一个任务当你需要指定一些代码稍后运行的时候，你可以使用dart:async提供的两种方式： Future类，它可以向event队列的尾部添加一个事件。 使用顶级方法scheduleMicrotask()，它可以向microtask队列的尾部添加一个微任务。 使用合理的队列有可能的还是尽量使用Future来向event队列添加事件。使用event队列可以保持microtask队列的简短，以此减少microtask的过度使用导致event队列的堵塞。如果一个任务确实要在event队列的任何一个事件前完成，那么你应该尽量直接写在main方法中而不是使用这两个队列。如果你不能那么就用scheduleMicrotask来向microtask添加一个微任务。 Event队列使用new Future或者new Future.delayed()来向event队列中添加事件。 注意:你也可以使用Timer来安排任务，但是使用Timer的过程中如果出现异常，则会退出程序。这里推荐使用Future，它是构建在Timer之上并加入了更多的功能，比如检测任务是否完成和异常反馈。 立刻需要将任务加入event队列可以使用new Future 1234//向event队列中添加一个任务new Future(() &#123; //任务具体代码&#125;); 你也可以使用then或者whenComplete在Future结束后立刻执行某段代码。如下面这段代码在这个Future被执行后会立刻输出42： 123new Future(() =&gt; 21) .then((v) =&gt; v*2) .then((v) =&gt; print(v)); 如果要在一段时间后添加一个任务，可以使用new Future.delayed(): 1234// 一秒以后将任务添加至event队列new Future.delayed(const Duration(seconds:1), () &#123; //任务具体代码&#125;); 虽然上面这个例子中一秒后向event队列添加一个任务，但是这个任务想要被执行的话必须满足一下几点： main方法执行完毕 microtask队列为空 该任务前的任务全部执行完毕 所以该任务真正被执行可能是大于1秒后。 关于Future的有趣事实： 被添加到then()中的方法会在Future执行后立马执行(这方法没有被加入任何队列，只是被回调了)。 如果在then()调用之前Future就已经执行完毕了，那么会有一个任务被加入到microtask队列中。这个任务执行的就是被传入then的方法。 Future()和Future.delayed()构造方法并不会被立刻完成，他们会向event队列中添加一个任务。 3.1. Future.value()构造方法会在一个microtask中完成。 3.2. Future,sync()构造方法会立马执行其参数方法，并在microtask中完成。 Microtask队列： scheduleMicrotask()dart:async定义了一个顶级方法scheduleMicrotask() ，你可以这样使用： 123scheduleMicrotask(() &#123; // ...code goes here...&#125;); 如果有必要可以使用isolate或worker如果你想要完成一些重量级的任务，为了保证你应用可响应，你应该将任务添加到isolate或者worker中。isolate可能会运行在不同的进程或线程中.这取决于Dart的具体实现。 那一般情况下你应该使用多少个isolate来完成你的工作呢？通常情况下可以根据你的cpu的个数来决定。 但你也可以使用超过cpu个数的isolate，前提是你的app能有一个好的架构。让不同的isolate来分担不同的代码块运行，但这前提是你能保证这些isolate之间没有数据的共享。 测试一下你的理解程度目前为止你已经掌握了调度任务的基本知识，下面来测试一下你的理解程度。 问题1下面这段代码的输出是什么？ 1234567891011121314import 'dart:async';main() &#123; print('main #1 of 2'); scheduleMicrotask(() =&gt; print('microtask #1 of 2')); new Future.delayed(new Duration(seconds:1), () =&gt; print('future #1 (delayed)')); new Future(() =&gt; print('future #2 of 3')); new Future(() =&gt; print('future #3 of 3')); scheduleMicrotask(() =&gt; print('microtask #2 of 2')); print('main #2 of 2');&#125; 别急着看答案，自己在纸上写写答案呢？ 答案： 1234567main #1 of 2main #2 of 2microtask #1 of 2microtask #2 of 2future #2 of 3future #3 of 3future #1 (delayed) 上面的答案是否就是你所期望的呢？这段代码一共执行了三个分支： main()方法 microtask队列 event队列（先new Future后new Future.delayed） main方法中的普通代码都是同步执行的，所以肯定是main打印先全部打印出来，等main方法结束后会开始检查microtask中是否有任务，若有则执行，执行完继续检查microtask，直到microtask列队为空。所以接着打印的应该是microtask的打印。最后会去执行event队列。由于有一个使用的delay方法，所以它的打印应该是在最后的。 问题2下面这个问题相对有些复杂： 123456789101112131415161718192021222324252627import 'dart:async';main() &#123; print('main #1 of 2'); scheduleMicrotask(() =&gt; print('microtask #1 of 3')); new Future.delayed(new Duration(seconds:1), () =&gt; print('future #1 (delayed)')); new Future(() =&gt; print('future #2 of 4')) .then((_) =&gt; print('future #2a')) .then((_) &#123; print('future #2b'); scheduleMicrotask(() =&gt; print('microtask #0 (from future #2b)')); &#125;) .then((_) =&gt; print('future #2c')); scheduleMicrotask(() =&gt; print('microtask #2 of 3')); new Future(() =&gt; print('future #3 of 4')) .then((_) =&gt; new Future( () =&gt; print('future #3a (a new future)'))) .then((_) =&gt; print('future #3b')); new Future(() =&gt; print('future #4 of 4')); scheduleMicrotask(() =&gt; print('microtask #3 of 3')); print('main #2 of 2');&#125; 答案： 123456789101112131415main #1 of 2main #2 of 2microtask #1 of 3microtask #2 of 3microtask #3 of 3future #2 of 4future #2afuture #2bfuture #2cmicrotask #0 (from future #2b)future #3 of 4future #4 of 4future #3a (a new future)future #3bfuture #1 (delayed) 总结以下有几点关于dart的事件循环机制需要牢记于心： Dart事件循环执行两个队列里的事件：event队列和microtask队列。 event队列的事件来自dart（future，timer，isolate message等）和系统（用户输入，I/O等）。 目前为止，microtask队列的事件只来自dart。 事件循环会优先清空microtask队列，然后才会去处理event队列。 当两个队列都清空后，dart就会退出。 main方法，来自event队列和microtask队列的所有事件都运行在Dart的main isolate中。 当你要安排一个任务时，请遵守以下规则： 如果可以，尽量将任务放入event队列中。 使用Future的then方法或whenComplete方法来指定任务顺序。 为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。 大计算量的任务放入额外的isolate中。 Isolate通过上面的文章，我们可以知道为什么在上一章节中的异步代码的执行结果都是在main()方法执行完毕后才输出。同时，文章引入了一个新的概念：Isolate。 Dart 没有并发时的共享状态，所有 Dart 代码都是 Isolate 中运行的，包括最初的 main() Isolate（也称为 root Isolate）。Dart 内建了 Isolate 机制，类似于 Actor ，仅在端口（Port）上通过消息进行通信。 每个 Isolate 有它自己的堆（Heap）和栈（Stack），彼此隔离。消息在接收前被复制，这样 Isolate 之间就无法操作相同的对象了。因为状态是彼此隔离的，所以这种并发编程模式不需要锁、互斥量什么的。 每个 Isolate 有它自己的堆内存，这意味着其中所有内存中的值，包括全局数据，都仅对该 Isolate 可见。Isolate 之间的通信只能通过传递消息的机制完成。消息通过端口（port）收发。 Isolate 只是一个概念，具体一个 Isolate 是什么取决于如何实现。比如，在 Dart VM 中一个 Isolate 可能是会是一个线程，在 Web 中可能会是一个 Web Worker 。 创建IsolateDart将Isolate的概念具现化为Isolate类，通过import &#39;dart:isolate&#39;;引入Isolate的包即可调用相关方法。 Isolate以函数作为运行载体——类似于Java中的Thread，最终会运行作为载体所传入的Runnable的run()方法。 创建一个Isolate的方式有两种，分别为spawn()和spawnUri()： 123456789101112131415161718Future&lt;Isolate&gt; spawn&lt;T&gt;( void entryPoint(T message), T message, &#123;bool paused: false, bool errorsAreFatal, SendPort onExit, SendPort onError&#125;)Future&lt;Isolate&gt; spawnUri( Uri uri, List&lt;String&gt; args, var message, &#123;bool paused: false, SendPort onExit, SendPort onError, bool errorsAreFatal, bool checked, Map&lt;String, String&gt; environment, Uri packageRoot, Uri packageConfig, bool automaticPackageResolution: false&#125;) spawn()比较常用的是第一种方法spawn()，传入的参数为返回void类型的函数和该函数的所能接收的参数。例如： 123456789import 'dart:isolate';void newIsolate(_)&#123; print(\"new isolate!\");&#125;void main()&#123; Isolate.spawn(newIsolate, null);&#125; 因为传入的函数必须为可传入参数的类型，所以如果只想调用函数而不需要任何传入值，可以将函数的参数类型设为dymanic，这样调用spawn()时后面可以传入null。 事实上，spawn()方法中说到，通常传入函数的参数类型为SendPort，这样Isolate就可以跟外部的其他Isolate进行通信、传递消息。 spawnUri()Isolate还可以通过URI链接调用对应的dart文件中的main()方法，这种模式有点像远程加载或者动态组件化的意思，因为除了可以调用本地的dart文件，还可以调用远程的dart文件（比如Http资源）。 spawnUri()必须传入的参数有三个，第一个是dart文件所在的URI，第二个参数类似于Java中的main(String[] args)，是一个List&lt;String&gt;类型的，第三个是任意参数，一般为SendPort。 123456789import 'dart:isolate';void main()&#123; var response = new ReceivePort(); Future&lt;Isolate&gt; remote = Isolate.spawnUri(Uri.parse(\"uriEcho.dart\"), [], response.sendPort); remote.then((isolate)&#123; response.close(); &#125;);&#125; 其中uriEcho.dart文件内容如下： 123main()&#123; print(\"uriEcho\");&#125; 在当前版本下，我在本机的测试中发现，如果第三个参数不传入SendPort，spawnUri()不会执行；如果传入SendPort，不手动调用close()的话，主线程会一直等待Isolate返回消息。 值得一提的是，两个创建方法的返回对象都是Future，这意味着可以使用async和await协调处理Isolate 退出Isolate要退出Isolate，调用kill()方法即可，注意kill()方法可传入的参数有两个： Isolate.immediate Isolate.beforeNextEvent 要理解关于这两个函数的含义，需要先了解Isolate类中的变量controlPort。controlPort的类型为SendPort，根据名称可知，该controlPort是用于发送Isolate的相关控制消息。这里的所谓控制消息，根据注释，指的是Isolate的暂停（pause）、终止（terminate）等操作。 Isolate本质上依然是事件队列的循环调用，只是运行环境产生了隔离并且可以并行运行，因此controlPort所发出的控制消息，最终还是发到事件队列中，等待循环执行。 因此调用kill()方法时，根据不同的参数，【终止】这一命令将会位于事件队列中的不同位置。 根据注释的解释，immediate表示将【终止】操作插入到当前事件队列尾部，这表示在终止操作之前的所有控制操作都将被执行；beforeNextEvent表示将【终止】操作插入到当前事件队列正在执行的事件之后。 例如，下面为当前的操作事件队列，队列中目前有N个事件： 1234567891011+-----------+| event 1 |+-----------+| event 2 |+-----------+| || ...... || |+-----------+| event N |+-----------+ 当调用kill(Isolate.immediate)时，immediate的操作事件将插入到操作队列底部： 12345678910111213+-----------+| event 1 |+-----------+| event 2 |+-----------+| || ...... || |+-----------+| event N |+-----------+| immediate | &lt;--- insert+-----------+ 当调用kill(Isolate.beforeNextEvent)时，beforeNextEvent的操作事件插在当前运行的event1事件之下： 12345678910111213+-----------------+| event 1 |+-----------------+| beforeNextEvent | &lt;--- insert+-----------------+| event 2 |+-----------------+| || ...... || |+-----------------+| event N |+-----------------+ 这个是我根据注释作出的理解，也许有不对的地方，因为Isolate没有操作事件相关的监听事件，也没办法进行测试。 测试kill()的功能时可以将Isolate传入的函数内sleep一段时间，不然会觉得kill()没效果。 ReceivePort &amp; SendPortIsolate之间是相互隔离的，要相互传递数据、消息时，就需要依靠ReceivePort和SendPort。这两个类的定义都在dart:isolate的isolate:dart中。 ReceivePort前面也说到，Dart基本所有操作都是基于消息队列的，类似于Android中的Handler。这里的ReceivePort也一样。 1var receivePort = new ReceivePort; 需要注意的一点是，当ReceivePort被创建时起，创建其的Isolate环境将一直运行下去，直到ReceivePort被调用close()。我的推测是ReceivePort不断往Isolate的Event queue填充任务，导致event loop一直无法停止，所以Isolate环境一直在运行。 从ReceivePort的定义中可以看到，它是实现了Stream的接口的，所以使用ReceivePort来接收数据、消息时，可以使用Stream的方式——listen()方法和await-for方式： 12345678910//listen方法receivePort.listen((v)&#123; //TODO: do something here&#125;)//await-forawait for(var msg in receivePort)&#123; var data = msg[0]; //TODO: do something here&#125; 只要不调用close()方法，ReceivePort就会一直接收数据消息。 SendPortSendPort的作用比较简单，查看它类的定义就会发现，它只有一个常用函数： 1void send(var message); 使用方式非常简单，但要注意的是它对发送的消息类型有所限制，能发送的类型有： null num bool double String SendPort List Map Set ReceivePort本身不能被发送 SendPort本身无法被用户创建，它与ReceivePort是绑定在一起的，即初始化一个ReceivePort时，其对应的SendPort作为它的成员变量一同被创建，它们之间是一对一的关系，一个SendPort所发送的消息只能被创建它的ReceivePort所接收。 所以，如果你希望同一个ReceivePort能接收多个不同Isolate内的消息数据，可以将该ReceivePort的SendPort发送给各个Isolate即可。 注意点ReceivePort有一点需要注意，首先其listen()方法定义如下： 12StreamSubscription listen(void onData(var message), &#123;Function onError, void onDone(), bool cancelOnError&#125;); 其中，listen()方法只会回调onData()和onDone()函数，而onError()永远不会被调用，cancelOnError则设置无效，关于这一点在其类定义的注释上有说明。 pause &amp; resume手动调用pause()Isolate允许暂停(pause)和继续(resume)，其分别对应的方法为： 123Capability pause([Capability resumeCapability]);void resume(Capability resumeCapability); 手动调用pause()方法时，如果传入的Capability为null，pause()会返回一个新的Capability对象。 这个Capability对象用于标识一次pause请求，所以按照注释所言，使用同一个Capability对象进行多次pause请求时，只需要使用相同的Capability对象调用resume()一次即可让Isolate继续执行；如果使用不同的Capability对象进行多次pause请求，则需要使用这些不同的Capability对象调用相应的resume()才能让Isolate继续执行。 pause请求有效的前提是Isolate的pauseCapability不为空 初始化调用pause请求在调用spawn()和spawnUri()时，可以设置其中的可选参数paused为true，这样Isolate在初始化完毕后会进入暂停状态，直到调用resume()后才开始执行。 通过这种情况暂停的Isolate，其对应的pause请求的Capability对象为其自身的成员变量pauseCapability，即： 123Isolate.spawn(newIsolate, receivePort.sendPort, pause:true).then((isolate) =&gt; isolate.resume(isolate.pauseCapability)); onError &amp; onExit在spawn()和spawnUri()中，分别有可选参数onError和onExit，此处的传入类型都为SendPort，即Isolate环境中发生的error和执行完毕的exit消息都会通过SendPort发送出去。 前面说过，ReceivePort的listen()只有onData()和onDone()会被回调，因此onError和onExit所传入的SendPort，最终发送出来的消息依然只会回调到其对应的ReceivePort的listen()中的onData()。 因此为了方便辨识对应的消息，一般会为对应的onError和onExit创建相应的ReceivePort。 如果不通过spawn()和spawnUri()传入onError和onExit，Isolate还有相应的函数提供调用： 123void addOnExitListener(SendPort responsePort, &#123;Object response&#125;);void addErrorListener(SendPort port); 这两个函数的效果和spawn()、spawnUri()传入的onError、onExit一致，并且addOnExitListener()方法还有可选参数response，可以设定当Isolate运行完毕退出时发送该response到指定的ReceivePort中，方便识别操作。","link":"/article/dev/2a8afc84.html"},{"title":"关于取模运算和取余运算","text":"事情起因是好久没碰C艹了，想着看看《C++ Primer》复习一下。然后看到了第33页中讲的unsigned char转型的描述： 例如，8比特大小的unsigned char可以表示0至255区间内的值，如果我们赋了一个区间意外的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8比特大小的unsigned char所得的结果是255。 看到这里，第一直觉是取余运算，即C艹或Java中的%，例如 3 % 2 = 1 。但后来发现取模和取余其实是不同的计算方式。以下引用百度百科中的描述： 对于整型数a，b来说，取模运算或者求余运算的方法都是： 1.求 整数商： c = a/b; 2.计算模或者余数： r = a - c*b. 求模运算和求余运算在第一步不同: 取余运算在取c的值时，向0 方向舍入(fix()函数)；而取模&gt; 运算在计算c的值时，向负无穷方向舍入(floor()函数)。 例如计算：-7 Mod 4 那么：a = -7；b = 4； 第一步：求整数商c，如进行求模运算c = -2（向负无穷方向舍入），求余c = -1（向0方向舍入）； 第二步：计算模和余数的公式相同，但因c的值不同，求模时r = 1，求余时r = -3。 归纳：当a和b符号一致时，求模运算和求余运算所得的c的值一致，因此结果一致。 当符号不一致时，结果不一样。求模运算结果的符号和b一致，求余运算结果的符号和a一致。 另外各个环境下%运算符的含义不同，比如c/c++，java 为取余，而python则为取模。 综上所述，取模和取余其实是同一个算法，区别只在于 对求商时，对商的取整方式不一样，简单来说： 取余：对商的取整方法为直接去掉小数点 取模：对商的取整方法为floor方法，即向下取整。可以先想象这个数在一条正常的数轴上，当这个数为小数时，取这个小数左边的整数。 当a、b符号不一致时： 取余：余数符号和a一致 取模：模的符号和b一致 如果要进行简单的测试，可以用Java提供的Math方法： 123456public static void main(String[] args) &#123; int a = -7; int b = 4; System.out.println(String.format(\"%d %% %d = %d\", a, b, a % b)); System.out.println(String.format(\"%d mod %d = %d\", a, b, Math.floorMod(a, b)));&#125; 输出： 12-7 % 4 = -3-7 mod 4 = 1","link":"/article/dev/701195a9.html"},{"title":"C++中typedef和指针结合时理解","text":"typedef可以定义一个类型的别名，一般常用的操作是定义一个结构体的别名，当然常用类型也可以，也可以加入指针： 1234typedef int* Fuck;Fuck p1;const Fuck p2 = 0;const Fuck *p3; 当typedef加入指针后，可能就比较难理解。诀窍是《C++ primer》中反复强调的： 从右往左看 首先看上面代码，定义了别名Fuck为int指针这种类型。 然后变量p1的类型自然是int指针。 而p2，首先从右开始，它是一个Fuck类型，然后被修饰了const，所以它是一个Fuck类型的常量。这时候再把别名Fuck换回原来的类型，则可知p2是一个类型为int指针的常量，即常量指针，是一个顶层const。 而p3，从右开始，它首先是一个指针，然后是一个Fuck的指针，然后被修饰了const，所以是一个指向常量Fuck的指针。这里再换回原来的类型，可知p3是一个指向了常量int指针的指针，是一个底层const。 其实疑惑的点在于*这个指针的修饰符，到底跟谁捆绑在一起。有的人可能会把p2直接改写为： 1const int* p2 = 0; 如果这样的话，其实*是优先跟p2捆在一起的，加上括号的话就比较好理解，即： 1const int (*p2) = 0; 也就是说，如果按照这种改写方式，其实我们定义p2是一个指向int常量的指针，是一个底层const。 而通过typedef定义的指针别名，加上括号来替换比较好理解，即： 1const (int*) p2 = 0; 这样就能理解p2是一个int指针的常量。","link":"/article/dev/6bd07504.html"},{"title":"C++中的顶层const","text":"既然有顶层const，自然就会有底层const。 顶层const：表示指针是一个常量 底层const：表示指向的对象是一个常量 只所以会出现这些定义，是因为在定义指针的时候，const关键字可以瞎几把放。一般来说，定义一个普通变量或引用时： 1234const int a1 = 1;int const a2 = 2;const int &amp;r1 = a1;int const &amp;r2 = a2; 上面代码中，定义的a1、a2都是常量对象，r1、r2都是常量引用。特别的，常量对象a1为顶层const，而常量引用r1为底层const。 而在指针上，则不同： 12345int a1 = 1;const int a2 = 2;const int *p1 = &amp;a2;int const *p2 = &amp;a1; 如上述代码中，指针p1表示的是指向的对象为const int，该指针无法改变其指向的对象的值，但可以改变其本身的地址值（即可以重新指向其他const int类型的对象）；指针p2表示的是指向的对象为int，但指针本身为const的，所以指针无法改变其本身的地址值（即无法重新指向其他对象），但可以看到，由于p2指向的对象为a1，a1为int类型的对象，则a1可以改变自己的值，那么p2的指向的对象的值也会改变。 基于开头所说的定义，可知指针p1是底层const，而指针p2是顶层const。 于是就会有奇怪的定义出现： 1const int *const p = &amp;i; 这种情况下的指针p属于既是顶层const又是底层const。","link":"/article/dev/531f17fa.html"},{"title":"C++的内存分配","text":"这里简单记一下，以防自己忘了。 C++的内存结构分为以下5种： 栈区(Stack) 堆区(Heap) bss段 data段(又叫GVAR) text段 网上的文章说法有两种，另外一种的结构为： 栈 堆 自由存储区(free store) 全局/静态存储区 常量存储区 上述的分类方法，其中强调了堆内存的生成使用malloc，而自由存储区(free store)使用new。这两种结构的分类网上的说法不一，但实际应该考虑C++的编译、运行环境来决定，因为C++的语言标准并没有决定堆、栈已经内存存储结构等概念。但一般来说，系统对于C++赋予的内存结构都是有堆和栈的，其余的结构用于存储我们日常不太关心的内容。 相关资料参考： https://www.zhihu.com/question/26224882 https://www.zhihu.com/question/66831911 https://blog.csdn.net/y_hanxiao/article/details/80690854 如图： 而内存的分配又分为两种： 静态分配 动态分配 内存结构栈区(Stack)在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限，其内存增长方式按内存地址由高到低方向生长，属于动态分配内存。 堆区(Heap)堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，按内存地址由低到高方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大，一般由malloc、new创建，属于动态分配内存。 每个线程都会有自己的栈，但是堆空间是共用的 bss段BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了，属于静态分配内存。 bss的例子：https://blog.csdn.net/zhengxianghdu/article/details/9022867 data段(又叫GVAR)有的地方叫GVAR(global value)，用来存放程序中已经初始化的非零全局变量。其中data有分为可读写区域和只读区域： 读写区域(RW)：存放非零全局变量、静态变量 只读区域(RO)：存放常量 属于静态分配内存。 text段也称为代码段(Code)，用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等）。该段内存为只读区域，并且为共享的,当有多个相同进程(Process)存在时，共用同一个text段。 下面代码简单描述一下变量各自存储的内存区间： 1234567891011121314151617181920int gValue;//未初始化的全局变量，存放在bssint gValue1 = 1;//已初始化的非0全局变量，存放在rwdatastatic int sValue;//未初始化的静态全局变量，存放在bssstatic int sValue1 = 2;//已初始化的静态全局变量，存放在rwdatastatic int sValue2 = 0;//初始化为0的静态全局变量，存放在bssconst int cValue = 1;//存放在rodataint main()&#123; int a;//栈 char s[] = \"abc\";//栈 char *p1;//栈 char *p2 = \"abcdef\";//p2在栈，\"abcdef\"在rodata上 static int lValue = 4;//存放在rwdata *p1 = (char *)malloc(10);//malloc分配的内存在堆上 strcpy(p1, \"123456\");//\"123456\"存放在rodata上 return 0;&#125;","link":"/article/dev/8a9fa889.html"},{"title":"setLayoutParams和onMeasure","text":"当我们使用setLayoutParams修改控件尺寸时，要注意控件内部的子View不一定会被回调onMeasure。所以会存在设置控件尺寸后，内部的子View尺寸没有被改变的情况。 具体原因看源码，setLayoutParams内部会回调requestLayout()，最终会触发父布局层层回调子View的onMeasure，但是在此之前会先判断子View的布局是否有被修改，因此可能会导致子View没有重新计算自己的尺寸。","link":"/article/dev/1f85290d.html"},{"title":"C++中的&和*","text":"关于C艹中的&amp;和*的作用，其实是比较基础的知识，但是一段时间不碰就要忘（记性不好），所以要做点笔记方便查找。 &amp;&amp;有两种用法，分别是在定义变量时作为引用和使用变量时作为取地址操作符。 引用在声明变量时，在变量名前加入&amp;，即表示为该变量类型的引用（左值引用，lvalue reference）。其中C++ Primer中特别强调： 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 其中引用必须在生命时赋值，而赋值的类型必须是一个对象。 1234int a = 1;int &amp;b = a; //正确int &amp;c = 2; //错误 引用在初始化赋值后，相当于绑定了其赋值的对象，并且无法让该引用重新绑定其他值。(C++ Primer中一直强调是绑定而非指向，这是很严谨的一种说法，避免混淆指针) 123456789101112131415#define LOGI(TAG, INFO) cout&lt;&lt;\"TAG:\"&lt;&lt;TAG&lt;&lt;\" || \"&lt;&lt;INFO&lt;&lt;endl;int a = 4;int b = 5;int &amp;r = a;LOGI(\"r\", r)LOGI(\"r\", &amp;r)LOGI(\"a\", &amp;a)LOGI(\"b\", &amp;b)r = b;LOGI(\"r\", r)LOGI(\"r\", &amp;r)LOGI(\"a\", &amp;a)LOGI(\"b\", &amp;b) 如上，最终的打印为：12345678TAG:r || 4TAG:r || 0x7fffa8aee308TAG:a || 0x7fffa8aee308TAG:b || 0x7fffa8aee30cTAG:r || 5TAG:r || 0x7fffa8aee308TAG:a || 0x7fffa8aee308TAG:b || 0x7fffa8aee30c 可以看到，引用r在声明时绑定了int类型的对象a，则其地址值一直跟a一致，无论后面对引用r进行什么操作，都相当于对a进行操作。 const引用 相关链接：C++中的顶层const const引用一般简称为常量引用，意指该引用绑定的是一个常量对象，是一个底层const。 常量引用不止可以绑定常量对象，也可以绑定常量值。其中特殊的一点是，还可以绑定非常量对象。 1234int i = 1;const int &amp;r1 = i;const int &amp;r2 = 2;const int &amp;r3 = r1 * 2; 如上，常量引用r1可以绑定非常量对象i。常量引用本身是无法再进行修改操作的，但其绑定的非常量对象可以进行修改。 特别注意的是，比如数值型的变量之间可以相互赋值，虽然会丢失精度，如double型的值直接可以直接赋值到int类型上。因此： 12345678double a = 3.14;LOGI(\"&amp;a\",&amp;a)const int &amp;r = a;LOGI(\"r\",r)LOGI(\"&amp;r\",&amp;r)a = 5.14;LOGI(\"r\",r)LOGI(\"&amp;r\",&amp;r) 如上，最终的打印为： 12345TAG:&amp;a || 0x7ffcb2c98968TAG:r || 3TAG:&amp;r || 0x7ffcb2c98964TAG:r || 3TAG:&amp;r || 0x7ffcb2c98964 可以看到，虽然表面上int型的常量引用r可以“绑定”double型对象a，但实际他们的地址并不相同。主要原因是编译器为了确保引用r可以绑定一个整数，在编译时增加了一个临时量对象。C++ Primer中的描述为： 所谓的临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。 因此，经过编译器编译后的代码可以理解为： 123double a = 3.1f;const int temp = a;const int &amp;r = temp; 因此，上面打印的引用r的地址值为临时量对象的地址值，而改变对象a的值，也不会改变引用r所绑定的对象的值。 取地址操作符&amp;用在已经声明的对象前面（注意不是在声明时使用），表示获取该对象的地址。这个比较常用，就不细说了。 **和&amp;一样有两种用法，分别是在定义变量时声明为指针和使用变量时作为解引用符。 指针引用C++ Primer中对指针的定义： 指针(Pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的简直访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 简单来说，指针是一种类型，用于指向另一个对象；而引用只是绑定对象。 123int i = 1;int *p = i;int *pp; 声明一个指针，只需要在声明变量时加入*即可。 解引用符*用在对象前面即表示为解引用符，解引用符只能用在指针类型的变量上。 C++ Primer中的定义： 对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值。","link":"/article/dev/42923d2a.html"},{"title":"Linux下罗技优联鼠标的简略指北","text":"最近陪我征战10多年的IO1.1光(左)荣(键)退(双)休(击)了，想来修修补补用到现在，实在不容易。如果微软出IO1.1复刻，我直接买爆。 本来可以再修一下继续用，但是想来还是不折腾了，直接下单MX Master 3。不得不说，手感确实还可以，办公一流，但前提是可以用Logitch Options。那么问题来了，罗技并没有出基于Linux版本的Logitch Options…… 为了解决这个问题，我所找到的方案有： solaar这个工具可以方便管理Unifying设备，同时具备查看设备电量、一定程度的功能定制等。比如在MX Master 3上，可以设定SmartShift的灵敏度、DPI值等。 但是有个问题，这个东西没有缓存配置，每次关掉再打开，设置就重制了。所以需要自己手动设置，相关配置文件在~/.config/solaar/config.json。 logidlogid可以设置Unifying鼠标的大部分按键和设置，比如DPI、SmartShift、SmartShift键、侧键以及手势键。不过由于只是映射按键，所以手势相比win和mac平台还是逊色不少。不过MX Master 3的手势键还是比较难按的，所以我折腾了一下发现不好用，就不管了。 相关设置可以在arch wiki中参考，这里贴一下自己的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122devices: (&#123; name: &quot;MX Master 3&quot;; smartshift: &#123; # true-开启间隔滚动；false-开启无阻力滚动 on: true; # 设置滚轮从SmartShift变成free-spin的速度 threshold: 30; &#125;; hiresscroll: &#123; # hires设定是否支持高分辨率模式，设置后会发现滚动特别快，所以设为false hires: false; # invert设定是否反转滚动 invert: false; # target设定滚路事件是否按HID++通知工作，true为HID++，false为正常模式。目前设置为true无法使用 target: false; &#125;; dpi: 400; buttons: ( &#123; cid: 0xc3; action = &#123; type: &quot;Gestures&quot;; gestures: ( &#123; direction: &quot;Up&quot;; mode: &quot;OnRelease&quot;; action = &#123; type: &quot;Keypress&quot;; keys: [&quot;KEY_LEFTMETA&quot;, &quot;KEY_D&quot;]; &#125;; &#125;, &#123; direction: &quot;Down&quot;; mode: &quot;OnRelease&quot;; action = &#123; type: &quot;Keypress&quot;; keys: [&quot;KEY_LEFTMETA&quot;, &quot;KEY_A&quot;]; &#125;; &#125;,# &#123;# direction: &quot;Left&quot;;# mode: &quot;OnRelease&quot;;# action =# &#123;# type: &quot;CycleDPI&quot;;# dpis: [50, 500, 1000, 1500, 2000, 3000, 4000];# &#125;;# &#125;, &#123; direction: &quot;Left&quot;; mode: &quot;OnRelease&quot;; action = &#123; type: &quot;Keypress&quot;; keys: [&quot;KEY_LEFTALT&quot;, &quot;KEY_1&quot;]; &#125;; &#125;,# &#123;# direction: &quot;Right&quot;;# mode: &quot;OnRelease&quot;;# action =# &#123;# type = &quot;ToggleHiresScroll&quot;;# &#125;# &#125;, &#123; direction: &quot;Right&quot;; mode: &quot;OnRelease&quot;; action = &#123; type: &quot;Keypress&quot;; keys: [&quot;KEY_LEFTALT&quot;, &quot;KEY_2&quot;]; &#125; &#125;, &#123; direction: &quot;None&quot; mode: &quot;onRelease&quot;; action = &#123; type: &quot;Keypress&quot;; keys: [&quot;KEY_LEFTMETA&quot;]; &#125; &#125; ); &#125; &#125;, &#123; cid: 0xc4; action = &#123; type = &quot;ToggleSmartshift&quot;; &#125;; &#125;, &#123; # Next tab instead of fwd in history, Comment to default behavior cid: 0x53; action = &#123; type : &quot;Keypress&quot;; keys: [&quot;KEY_FORWARD&quot;]; &#125;; &#125;, &#123; # Previous tab instead of back in history, Comment to default behavior cid: 0x56; action = &#123; type : &quot;Keypress&quot;; keys: [&quot;KEY_BACK&quot;]; &#125;; &#125; );&#125;); # 以上两款都可以同时存在，记得设置开机自启就行了 有一说一，这个鼠标还是在win和mac下使用更舒服，后面换电脑估计会换mac了。","link":"/article/dev/e7c3448c.html"},{"title":"OpenGLES开发透明通道视频备忘录","text":"最近在做带透明MP4视频的渲染播放，原理就是视频的一半是只有黑白颜色的透明通道，另一半则是视频原来的画面，只要利用OpenGLES在渲染时提取原来画面的对应位置上的透明通道的透明度，设置到原来画面的像素上，就可以达到播放透明视频的效果。 原理很简单，实现也不难，但是中间遇到了一些坑，折腾了一段时间才弄明白，主要原因还是基础原理不了解，还是要多学习。 1.像素采样位置偏差比如，一个视频的尺寸是1500x750，黑白透明通道在左边，原画面在右边，则实际渲染出来的视频大小应该是750x750。 OpenGL中，纹理的坐标原点在左下角，所以黑白透明通道的像素采样范围是(0,0)~(749,749)，原画面的像素采样范围是(750,0)~(1499,749)。因为OpenGLES中采样器接收的像素坐标是0~1的浮点型，所以换算过来约等于是(0.0,0.0)~(0.5,1)和(0.5,0.0)~(1.0,1.0)。 所以刚开始时，我在fragment shader中的写法很简单，将vertex shader传入的纹理坐标的x直接减去0.5，即可获得透明通道的像素值，根据这个值换算成透明度即可。但是在我的Mate30 Pro上，实际效果并不理想，在原画面的物体边缘可以看到有黑边。 为什么会这样呢？我第一时间认为这是采样问题。 线性过滤和最临近过滤我们称纹理的像素数据为纹素(texel)，由于texel和pixel是无法一一对应的，即无论如何都会存在放大或缩小的情况，这个时候就需要通过对纹理采样来进行纹理像素到屏幕像素的映射。 具体说明： 纹理过滤 Why do we need texture filtering in OpenGL? OpenGL Texture Coordinates in Pixel Space OpenGL-Texture Filtering(纹理过滤) 所以我们知道，假如OpenGL中的图元和纹理大小完全一致，那么texel和pixel将完全对应，这时候就不需要采样了，但这是不可能的。基于传入的纹理坐标去采样texel时，由于放大或者缩小的关系，可能会采样到目标texel的隔壁去，或者一次采样到多个texel，那么实际渲染到图元上时，要么失真要么锯齿化。 那么，假如我们对纹理精确采样，是不是就能解决这个问题呢？ texelFetchtexelFetch是OpenglES 3.0提供的新方法，用于精确采样texel，和texture方法不同，传入的纹理坐标是整型的，因此采样出来的texel也不会经过过滤处理。 改为texelFetch后，问题确实解决了。但实际效果并不理想，因为没有过滤，在屏幕上的显示是马赛克（锯齿）化的，像素之间的颜色不连贯。 而且我后来在魅族pro7上测试，发现使用texture方法却不会出现边缘黑边。这说明texelFetch并不是解决方法。 H264硬解码的宏块与SurfaceTexture的变换矩阵一般情况下，在Android中解码视频都会选择硬解码，速度快，效率高，节省资源。硬解码视频无非两种方式，使用MediaCodec手动解码或者MediaPlayer直接播放。两种方式都需要传入一个SurfaceTexture进去。 先说H264解码，在解码出一幅图像时，图像由N个宏块组成。宏块是H264中编解码的基本单位，一般一个宏块的大小都是16x16。 在Android上，H264硬编码、解码在一般情况下也是基于这个宏块大小为单位的，所以会有一个16位对齐的要求。在一些机型上，如果编码的视频尺寸没有对齐16位（即无法被16整除），最终出来的视频可能会花屏、绿屏之类的。而解码则不同，假如实际传入的视频不满足16为对齐，最终解码出来的图像尺寸，是原来尺寸除以16后向上取整再乘于16后得到的最临近原来视频尺寸、可被16整除的数值。 比如上述例子中的1500x750的视频，这个大小是无法被16整除的，所以实际渲染出来的视频大小，其实是： ceil((1500,750)/16)*16 = (1504,752) 因此，最终解码并传入到纹理单元中的纹理尺寸，其实不是我们以为的1500x750，而是1504x752。前面说到在vertex shader中，传入的纹理坐标范围是(0.0, 1.0)，假如我们不对坐标进行转换处理，最终渲染出来的图像是小于屏幕上设置的控件尺寸的。 所以我们需要SurfaceTexture的getTransformMatrix()方法，获取解码后经过变换的矩阵。这个变换矩阵的用处在于将传入的纹理采样坐标转换为真正的采样坐标。比如上述的1500x750的视频，解码输出为1504x752，那么变换矩阵是： $$S_x=1500\\div1504\\approx0.997340$$$$S_y=750\\div752\\approx0.997340$$$$M=\\begin{bmatrix}S_x\\\\S_y\\\\1\\end{bmatrix} \\times I_4 = \\begin{bmatrix}0.997340&amp;0&amp;0&amp;0\\\\0&amp;0.997340&amp;0&amp;0\\\\0&amp;0&amp;1&amp;0\\\\0&amp;0&amp;0&amp;1\\end{bmatrix}$$ 也就是说，要采样对应位置的透明通道texel，不能在转换了坐标之后才-0.5，需要先-0.5再进行转换，同时需要考虑到浮点型的精度，因为OpenGLES相对OpenGL的精度更低，无法准确判断一些边界值。 最终通过上述方法后，渲染出来的画面终于没有了边缘黑边，同时也没有了锯齿马赛克，达到理想效果。至于为什么在魅族pro7上硬解码出来的数据没有对齐16位，这个就不好说了，应该是各家底层有改造过。 2.SurfaceTexture销毁问题根据项目需求，我这边使用的是TextureView，通过内部给出的SurfaceTexture进行OpenGLES绘制。视乎需求，可能会需要长期保存这个SurfaceTexture，但是这样会导致一些问题，比如onDetachedFromWindow()中需要把这个SurfaceTexture释放掉，但是一般没有很好的解决方法。网上推荐的是使用ijkPlayer内的TextureView的保存SurfaceTexture方式，不过比较复杂。 最好的方式其实是不保存SurfaceTexture，让TextureView自己管理。然后自己在每次触发onSurfaceTextureAvailable()和onSurfaceTextureDestroyed()方法时，再进行对应的逻辑处理。 3.Android4.4的兼容性问题一开始我使用的是MediaCodec自行解码，但发现对应的native内存、graphics内存使用都有点偏高。后面使用MediaPlayer后，发现内存占用都很好，所以就一直使用了。但是发现在Android4.4下有兼容性问题。 MediaPlayer在离开当前页面时(比如onPause或者onDestroy())必须销毁，不然会出现在新页面无法使用的情况。 MediaPlayer存在底层状态异常的问题，有的机型一旦出现问题后，必须重启才能继续使用 MediaPlayer无法在同一界面同时使用多个，具体能同时播放多少个不好说，这个好像有随机性 为了解决这个问题，最终还是在Android4.4下使用MediaCodec。使用华为荣耀畅玩x4测试，在同一界面上可以稳定同时使用两个进行解码播放，从第三个开始就会出现异常，所以无法完全避免这种兼容性问题。","link":"/article/dev/763e0905.html"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"MediaCodec","slug":"MediaCodec","link":"/tags/MediaCodec/"},{"name":"OpenGLES","slug":"OpenGLES","link":"/tags/OpenGLES/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"罗技","slug":"罗技","link":"/tags/罗技/"},{"name":"Logitch","slug":"Logitch","link":"/tags/Logitch/"},{"name":"Logitch Options","slug":"Logitch-Options","link":"/tags/Logitch-Options/"},{"name":"MX Master 3","slug":"MX-Master-3","link":"/tags/MX-Master-3/"},{"name":"Solaar","slug":"Solaar","link":"/tags/Solaar/"},{"name":"logid","slug":"logid","link":"/tags/logid/"}],"categories":[{"name":"开发","slug":"dev","link":"/categories/dev/"},{"name":"骚灵","slug":"default","link":"/categories/default/"}]}
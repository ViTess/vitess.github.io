<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The ABC of Dart Part 7 - 异步 - Debug表演艺术家</title><meta name="description" content="ViTe&#39;s Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="QQchFmWKLy"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"><link rel="icon" href="https://vites.app/images/favicon.png"><script src="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/themes/black/pace-theme-flash.css" rel="stylesheet"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/bulma/0.6.2/css/bulma.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/lightgallery/1.6.10/css/lightgallery.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"><script src="//cdn.bootcdn.net/ajax/libs/moment.js/2.22.1/moment.min.js"></script><script>function setArticleTime(e,t){var d=moment(t),n=moment().diff(d,"days",!0);document.getElementsByClassName(e)[0].innerHTML=7<n?d.format("YYYY年MM月DD日 HH:mm:ss"):d.fromNow()}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?t(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],t):t(e.moment)}(this,function(e){"use strict";return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:11<=e?e:e+12},meridiem:function(e,t,d){var n=100*e+t;return n<600?"凌晨":n<900?"早上":n<1130?"上午":n<1230?"中午":n<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s内",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?40c23cf929965ff7dcc44d0e695ed794";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a class="navbar-item" href="/" style="padding:0 3rem 0 1rem"><img src="/images/logo.png" alt=""></a><div class="navbar-burger"><span></span><span></span><span></span></div></div><div class="navbar-menu navbar-start"> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-menu navbar-end"><a class="navbar-item search" href="javascript:;"><i class="fas fa-search"></i></a><div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only"><a class="navbar-item toc"><i class="fa fa-list"></i></a><div class="navbar-dropdown is-right"> <a class="navbar-item" href="#async和await">1 async和await</a><hr class="navbar-divider"> <a class="navbar-item" href="#Future-API">2 Future API</a> <a class="navbar-item" href="#then-的链式调用">2.1 then()的链式调用</a><hr class="navbar-divider"> <a class="navbar-item" href="#函数生成器">3 函数生成器</a> <a class="navbar-item" href="#同步生成器sync">3.1 同步生成器sync*</a> <a class="navbar-item" href="#异步生成器async">3.2 异步生成器async*</a> <a class="navbar-item" href="#Stream-API">3.2.1 Stream API</a></div></div><a class="navbar-item" href="https://github.com/vitess"><i class="fab fa-github"></i></a><a class="navbar-item" href="https://weibo.com/2373803622"><i class="fab fa-weibo"></i></a><a class="navbar-item" href="mailto:vite@outlook.com"><i class="fa fa-envelope-square"></i></a></div></div></nav><section class="section"><div class="container"><article class="article content gallery" itemscope itemprop="blogPost"><h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name"> The ABC of Dart Part 7 - 异步</h1><div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile"><span class="column is-narrow"><time class="article-time-ba35e115" datetime="2018-08-13T06:10:12.000Z" itemprop="datePublished"></time></span><span class="column is-narrow article-category"><i class="far fa-folder"></i> <a class="article-category-link" href="/categories/dev/">开发</a></span></div><div class="article-entry is-size-6-mobile" itemprop="articleBody"><p><code>Dart</code>中没有线程这种概念，或者说对线程进行了包装，调用者无法对线程进行直接的操作。所以<code>Dart</code>为异步操作提供了一些对应的API和关键字，分别有：</p><ul><li><code>async</code>和<code>await</code>关键字</li><li><code>Async*</code>、<code>sync*</code>、<code>yield*</code>关键字和<code>Stream</code>的API</li><li><code>Future</code>的API</li></ul><p>细分下来还是挺多内容的，尤其像<code>Stream</code>这种流式操作，网上相关的资料都叙述得不够详细。</p><a id="more"></a><h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a><code>async</code>和<code>await</code></h1><p><code>async</code>和<code>await</code>组合可以实现异步功能，并且使得代码看上去像是同步流程一样（网上说的）。</p><p>首先举个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">DateTime</span>.now());<span class="comment">// (1)</span></span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">DateTime</span>.now());<span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，最终会先打印(1)，间隔1秒后打印(2)，打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-08-13 15:40:13.585271</span><br><span class="line">2018-08-13 15:40:14.588507</span><br></pre></td></tr></table></figure><blockquote><p>其中<code>DateTime</code>来自包<code>dart:core</code>，而<code>sleep</code>方法来自包<code>date:io</code>。</p></blockquote><p>我们暂且把<code>main()</code>函数运行的环境称为“线程”。当调用<code>sleep</code>时，<code>Dart</code>的主线程会被阻塞，直到<code>sleep</code>结束才接着进行下一步操作，这些现象都跟其他语言相同。</p><p>但是我们可以通过将耗时操作异步执行，达到不阻塞主线程：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">callSleep() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    callSleep();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main start:2018-08-13 17:28:31.456818</span><br><span class="line">main end:2018-08-13 17:28:31.462557</span><br><span class="line">async start:2018-08-13 17:28:31.462995</span><br><span class="line">async end:2018-08-13 17:28:32.463558</span><br></pre></td></tr></table></figure><p>可以看到，主线程并没有被阻塞，异步操作则被<code>sleep</code>阻塞，但不会影响到主线程。</p><p>从上述代码中可以看出，<code>async</code>关键字用于修饰函数。当一个函数被<code>async</code>修饰时，该函数将返回一个<code>future</code>对象。被<code>async</code>修饰的函数，被调用时将运行在异步环境。</p><p><code>async</code>可以单独使用（修饰函数），但<code>await</code>则不行。<code>await</code>用于修饰返回<code>future</code>的函数，并且必须在带有<code>async</code>的函数内使用，它的作用为等待一个异步函数执行完毕。</p><p>例如，我有如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">callSleep() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">    callSleep2();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callSleep2() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"callSleep2 start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"callSleep2 start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    callSleep();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main start:2018-08-13 18:22:04.529513</span><br><span class="line">main end:2018-08-13 18:22:04.534770</span><br><span class="line">async start:2018-08-13 18:22:04.535263</span><br><span class="line">async end:2018-08-13 18:22:04.535454</span><br><span class="line">callSleep2 start:2018-08-13 18:22:04.537200</span><br><span class="line">callSleep2 start:2018-08-13 18:22:05.537942</span><br></pre></td></tr></table></figure><p>可以看到<code>callSleep2</code>是在<code>callSleep</code>运行之后才运行的。如果在<code>callSleep</code>中对<code>callSleep2</code>加入<code>await</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">callSleep() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">    <span class="keyword">await</span> callSleep2();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callSleep2() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"callSleep2 start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"callSleep2 start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now().toString()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    callSleep();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main start:2018-08-13 18:23:16.099116</span><br><span class="line">main end:2018-08-13 18:23:16.104197</span><br><span class="line">async start:2018-08-13 18:23:16.104623</span><br><span class="line">callSleep2 start:2018-08-13 18:23:16.106389</span><br><span class="line">callSleep2 start:2018-08-13 18:23:17.106978</span><br><span class="line">async end:2018-08-13 18:23:17.108346</span><br></pre></td></tr></table></figure><p>可以看出打印不同了。<code>callSleep</code>需要等到<code>callSleep2</code>的异步执行完毕之后才能继续执行。</p><h1 id="Future-API"><a href="#Future-API" class="headerlink" title="Future API"></a>Future API</h1><p>事实上，<code>Dart</code>中的异步执行操作都是依靠<code>Future</code>来实现的，即便是上述的<code>async</code>和<code>await</code>关键字，最终操作的依然是<code>Future</code>。</p><p><code>Future</code>所代表的含义，就是在调用时调用本身立即返回，并在稍后的某个时候执行完成时再获得返回结果。</p><p><code>Future</code>的定义在SDK的async包中，可以看出有好几种构造函数：</p><ol><li>Future(FutureOr<t> computation())</t></li><li>Future.microtask(FutureOr<t> computation())</t></li><li>Future.sync(FutureOr<t> computation())</t></li><li>Future.value([FutureOr<t> value])</t></li><li>Future.error(Object error, [StackTrace stackTrace])</li><li>Future.delayed(Duration duration, [FutureOr<t> computation()])</t></li></ol><p>其中最常用的构造函数是1和6。事实上，如果接触过<code>RxJava</code>，对于<code>Future</code>的使用方式会容易理解一些，因为基本的构造、链式调用等一系列方法都非常相似。</p><p>例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; future = <span class="keyword">new</span> Future(() &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"future start:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    future.then((i) =&gt; <span class="built_in">print</span>(<span class="string">"future end:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main start:2018-08-16 15:31:15.543445</span><br><span class="line">main end:2018-08-16 15:31:15.550062</span><br><span class="line">future start:1, time:2018-08-16 15:31:15.551202</span><br><span class="line">future end:2, time:2018-08-16 15:31:16.554641</span><br></pre></td></tr></table></figure><p></p><p><code>Future(FutureOr&lt;T&gt; computation())</code>这个构造函数相当于<code>RxJava</code>中的<code>Observable.create()</code>方法，将需要异步执行的操作包裹在函数，将该函数作为参数传递给<code>Future</code>。</p><p><code>Future</code>在<code>main()</code>外初始化时不会立即执行，直到被<code>main()</code>调用时则开始执行，这一点和<code>RxJava</code>不同，<code>RxJava</code>必须调用<code>subscribe()</code>才开始调用。</p><p>如果需要在<code>Future</code>执行完毕后获取异步执行的结果来进行一些操作，可以使用<code>then()</code>来执行，这一点跟<code>RxJava</code>的<code>subscribe()</code>操作相同。</p><p>同时，<code>then</code>具有可选参数<code>Function onError</code>，可以用来处理<code>Future</code>在执行过程中出现异常的情况。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; future = <span class="keyword">new</span> Future(() &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"future start:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentError(<span class="string">"Custom Error"</span>);</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    future.then((i) =&gt; <span class="built_in">print</span>(<span class="string">"future end:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>),</span><br><span class="line">            onError: (e) =&gt; <span class="built_in">print</span>(<span class="string">"catch error:$e"</span>));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main start:<span class="number">2018</span><span class="number">-08</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">03.173648</span></span><br><span class="line">main end:<span class="number">2018</span><span class="number">-08</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">03.180109</span></span><br><span class="line">future start:<span class="number">1</span>, time:<span class="number">2018</span><span class="number">-08</span><span class="number">-16</span> <span class="number">15</span>:<span class="number">41</span>:<span class="number">03.181231</span></span><br><span class="line"><span class="keyword">catch</span> error:Invalid argument(s): Custom Error</span><br></pre></td></tr></table></figure><p>可以看到，如果<code>Future</code>内部出现了异常，将不会返回结果到<code>then()</code>中的第一个函数，而是将异常返回给第二个<code>onError</code>函数。</p><h2 id="then-的链式调用"><a href="#then-的链式调用" class="headerlink" title="then()的链式调用"></a>then()的链式调用</h2><p>有时候我们可能需要在<code>Future</code>之后执行多步操作，并且每一步操作都依赖于上一步的结果。对此我们当然可以把相关操作写在同一个<code>then()</code>里面。但是<code>Dart</code>提供了对应的链式调用，使得我们可以用多个<code>then()</code>将不同的操作串联起来：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:io'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:core'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">int</span>&gt; future = <span class="keyword">new</span> Future(() &#123;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"future start:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    sleep(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main start:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">    future.then((i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"first then:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;).then((i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"second then:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;).then((i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"third then:$i, time:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"main end:<span class="subst">$&#123;<span class="keyword">new</span> DateTime.now()&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main start:2018-08-16 15:53:53.024344</span><br><span class="line">main end:2018-08-16 15:53:53.030724</span><br><span class="line">future start:1, time:2018-08-16 15:53:53.031873</span><br><span class="line">first then:2, time:2018-08-16 15:53:54.034334</span><br><span class="line">second then:3, time:2018-08-16 15:53:54.034514</span><br><span class="line">third then:4, time:2018-08-16 15:53:54.034651</span><br></pre></td></tr></table></figure><p>我们在<code>then()</code>操作中可以将结果返回给下一个<code>then()</code>，并且参数类型不限定于<code>Future</code>返回的类型。</p><p><code>Future</code>还有许多API，可以配合链式调用随意组合，具体的就不细说了。</p><h1 id="函数生成器"><a href="#函数生成器" class="headerlink" title="函数生成器"></a>函数生成器</h1><p>函数生成器是指利用惰性函数计算结果序列，以提升性能。就我的理解而言，类似于在函数内生成一个闭包，然后可以经过循环得到一系列结果，但结果并不是一次性返回，而是像一段数据流一样每次返回一个结果。</p><p>具体使用场景，自己还没想到，也许在一些需要递归或者循环调用返回的场景能用到吧。</p><h2 id="同步生成器sync"><a href="#同步生成器sync" class="headerlink" title="同步生成器sync*"></a>同步生成器<code>sync*</code></h2><p>使用<code>sync*</code>修饰函数时，函数将自动返回一个<code>Iterable</code>类型的实例，并可以根据该实例获取<code>Iterator</code>类型的迭代器。通过迭代器的函数<code>moveNext()</code>判断是否存在下一个值，通过<code>current</code>获取下一个值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> syncGenerator(<span class="built_in">int</span> i) <span class="keyword">sync</span>* &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"syncGenerator start"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> value = <span class="number">0</span>; value &lt; i; value++) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"syncGenerator yield"</span>);</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"syncGenerator end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">Iterator</span> iterator = syncGenerator(<span class="number">3</span>).iterator;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">    <span class="keyword">while</span> (iterator.moveNext()) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"start while"</span>);</span><br><span class="line">        <span class="built_in">print</span>(iterator.current);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"end while"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，使用<code>sync*</code>制作生成器时，函数的内部需要通过<code>yield</code>关键字来声明需要输出的结果。<code>yield</code>表示生成，其实际操作类似于<code>return</code>，可用于声明结果或者是表达式。</p><p>上述输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">syncGenerator start</span><br><span class="line">syncGenerator yield</span><br><span class="line">start while</span><br><span class="line">0</span><br><span class="line">end while</span><br><span class="line">syncGenerator yield</span><br><span class="line">start while</span><br><span class="line">1</span><br><span class="line">end while</span><br><span class="line">syncGenerator yield</span><br><span class="line">start while</span><br><span class="line">2</span><br><span class="line">end while</span><br><span class="line">syncGenerator end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>可以看出，当调用生成器<code>syncGenerator()</code>时，生成器内部并未开始执行，直到调用<code>moveNext()</code>函数时，生成器开始运行，并进入循环，直到遇到<code>yield</code>所在行后，将在此暂停，并将结果返回到外部，注意此时生成器的内部环境依然保存着不变；当外部再次调用<code>moveNext()</code>时，生成器将由暂停变为继续运行，直到内部满足条件，不再运行到<code>yield</code>所在行，生成器运行结束。</p><p>当然，由于同步生成器返回的是<code>Iterable</code>，所以可以使用<code>Dart</code>提供的API进行链式调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterable</span> syncGenerator(<span class="built_in">int</span> i) <span class="keyword">sync</span>* &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"syncGenerator start"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> value = <span class="number">0</span>; value &lt; i; value++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"syncGenerator end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    syncGenerator(<span class="number">3</span>).forEach((i) =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syncGenerator start</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">syncGenerator end</span><br></pre></td></tr></table></figure><h2 id="异步生成器async"><a href="#异步生成器async" class="headerlink" title="异步生成器async*"></a>异步生成器<code>async*</code></h2><p>异步生成器的原理和同步生成器基本相同，不同的是由于异步生成器运行在异步环境，因此返回的不是<code>Iterable</code>而是<code>Stream</code>。因此这里涉及到了<code>Stream</code>的相关操作和API。</p><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p><code>Stream</code>表示一个数据的流，关于流的概念和其他语言里的流的理解基本相同（比如Java8中的Stream），这里引用一下<a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener"><code>Java</code>中对<code>Stream</code>的定义</a>：</p><blockquote><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p></blockquote><blockquote><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p></blockquote><blockquote><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stream asyncGenerator(<span class="built_in">int</span> i) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"asyncGenerator start"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> value = <span class="number">0</span>; value &lt; i; value++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"asyncGenerator end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">    asyncGenerator(<span class="number">3</span>).listen((i) =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">asyncGenerator start</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">asyncGenerator end</span><br></pre></td></tr></table></figure><p>可以看到由于异步执行，生成器的输出在<code>main()</code>执行完后才执行。</p><p><code>listen()</code>方法相当于<code>RxJava</code>中的<code>subscribe()</code>方法，目的都是添加响应数据的方法，并且都会返回一个可以控制流的对象。通过<code>listen()</code>返回的控制对象类型为<code>StreamSubscription</code>。通过<code>StreamSubscription</code>可以方便地操控流：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Stream asyncGenerator(<span class="built_in">int</span> i) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"asyncGenerator start"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> value = <span class="number">0</span>; value &lt; i; value++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"asyncGenerator end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start"</span>);</span><br><span class="line">    StreamSubscription subscription = asyncGenerator(<span class="number">3</span>).listen(</span><br><span class="line">            <span class="keyword">null</span>, onDone: () =&gt; <span class="built_in">print</span>(<span class="string">"done"</span>));</span><br><span class="line">    subscription.onData((i) &#123;</span><br><span class="line">        <span class="built_in">print</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            subscription.cancel().then((f) =&gt; <span class="built_in">print</span>(<span class="string">"cancel"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">asyncGenerator start</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">cancel</span><br></pre></td></tr></table></figure><p>可以看到<code>cancel()</code>操作会将异步生成器中断，不会使其运行到最后一步。</p></div><div class="columns is-variable is-1 is-multiline is-mobile"><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Dart/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> Dart</a></span></div><div class="columns is-mobile is-multiline article-nav"> <span class="column is-12-mobile is-half-desktop article-nav-prev"><a href="/article/dev/2a8afc84.html">The ABC of Dart Part 8 - 并发</a></span> <span class="column is-12-mobile is-half-desktop article-nav-next"><a href="/article/dev/cd32d183.html">The ABC of Dart Part 6 - 库类的引用</a></span></div><script>setArticleTime("article-time-ba35e115","Mon Aug 13 2018 14:10:12 GMT+0800")</script></article><div class="sharebox"><div class="addthis_inline_share_toolbox"></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5af91abd06c0d49f"></script></div><div class="comments"><h3 class="title is-4">评论</h3><div id="valine-thread"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"GUCbjfNG4dzXp1OK5wLej8sB-gzGzoHsz",app_key:"8g2nRqttkIwqsgHOOsEzRvX2",placeholder:"我有一言，请诸位静听",avatar:"identicon"})</script></div></div></section><footer class="footer"><div class="container"><div class="columns content"><div class="column is-narrow has-text-centered"> &copy; 2022 Vincent Tam&nbsp; Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a></div><div class="column is-hidden-mobile"></div></div></div></footer><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"></script><script>$(document).ready(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script>window.FontAwesomeConfig={searchPseudoElements:!0}</script><script>window.MathJax={chtml:{matchFontHeight:!1},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"},tex:{autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script src="//cdn.bootcdn.net/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script><script>!function(e){e(document).ready(function(){"function"==typeof e.fn.lightGallery&&e(".article.gallery").lightGallery({selector:".gallery-item"}),"function"==typeof e.fn.justifiedGallery&&e(".justified-gallery").justifiedGallery()})}(jQuery)</script><script src="/js/script.js"></script><div class="searchbox ins-search"><div class="searchbox-mask"></div><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></body></html>
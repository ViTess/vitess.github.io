<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>C++中的&amp;和* - Debug表演艺术家</title><meta name="description" content="ViTe&#39;s Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="QQchFmWKLy"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"><link rel="icon" href="https://vites.app/images/favicon.png"><script src="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/themes/black/pace-theme-flash.css" rel="stylesheet"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/bulma/0.6.2/css/bulma.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/lightgallery/1.6.10/css/lightgallery.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"><script src="//cdn.bootcdn.net/ajax/libs/moment.js/2.22.1/moment.min.js"></script><script>function setArticleTime(e,t){var d=moment(t),n=moment().diff(d,"days",!0);document.getElementsByClassName(e)[0].innerHTML=7<n?d.format("YYYY年MM月DD日 HH:mm:ss"):d.fromNow()}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?t(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],t):t(e.moment)}(this,function(e){"use strict";return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:11<=e?e:e+12},meridiem:function(e,t,d){var n=100*e+t;return n<600?"凌晨":n<900?"早上":n<1130?"上午":n<1230?"中午":n<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s内",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?40c23cf929965ff7dcc44d0e695ed794";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a class="navbar-item" href="/" style="padding:0 3rem 0 1rem"><img src="/images/logo.png" alt=""></a><div class="navbar-burger"><span></span><span></span><span></span></div></div><div class="navbar-menu navbar-start"> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-menu navbar-end"><a class="navbar-item search" href="javascript:;"><i class="fas fa-search"></i></a><div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only"><a class="navbar-item toc"><i class="fa fa-list"></i></a><div class="navbar-dropdown is-right"> <a class="navbar-item" href="#amp">1 &amp;</a> <a class="navbar-item" href="#引用">1.1 引用</a> <a class="navbar-item" href="#const引用">1.2 const引用</a> <a class="navbar-item" href="#取地址操作符">1.3 取地址操作符</a><hr class="navbar-divider"> <a class="navbar-item" href="#">2 *</a> <a class="navbar-item" href="#指针">2.1 指针</a> <a class="navbar-item" href="#解引用符">2.2 解引用符</a></div></div><a class="navbar-item" href="https://github.com/vitess"><i class="fab fa-github"></i></a><a class="navbar-item" href="https://weibo.com/2373803622"><i class="fab fa-weibo"></i></a><a class="navbar-item" href="mailto:vite@outlook.com"><i class="fa fa-envelope-square"></i></a></div></div></nav><section class="section"><div class="container"><article class="article content gallery" itemscope itemprop="blogPost"><h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name"> C++中的&amp;和*</h1><div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile"><span class="column is-narrow"><time class="article-time-42923d2a" datetime="2019-08-01T12:22:52.000Z" itemprop="datePublished"></time></span><span class="column is-narrow article-category"><i class="far fa-folder"></i> <a class="article-category-link" href="/categories/dev/">开发</a></span></div><div class="article-entry is-size-6-mobile" itemprop="articleBody"><p>关于C艹中的<code>&amp;</code>和<code>*</code>的作用，其实是比较基础的知识，但是一段时间不碰就要忘（记性不好），所以要做点笔记方便查找。</p><a id="more"></a><h1 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h1><p><code>&amp;</code>有两种用法，分别是在定义变量时作为<strong>引用</strong>和使用变量时作为取地址操作符。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在声明变量时，在变量名前加入<code>&amp;</code>，即表示为该变量类型的引用（左值引用，lvalue reference）。其中C++ Primer中特别强调：</p><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote><p>其中引用必须在生命时赋值，而赋值的类型必须是一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b = a; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">2</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>引用在初始化赋值后，相当于<strong>绑定</strong>了其赋值的对象，并且无法让该引用重新<strong>绑定</strong>其他值。(C++ Primer中一直强调是<strong>绑定</strong>而非指向，这是很严谨的一种说法，避免混淆指针)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(TAG, INFO) cout&lt;&lt;<span class="meta-string">"TAG:"</span>&lt;&lt;TAG&lt;&lt;<span class="meta-string">" || "</span>&lt;&lt;INFO&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = a;</span><br><span class="line">LOGI(<span class="string">"r"</span>, r)</span><br><span class="line">LOGI(<span class="string">"r"</span>, &amp;r)</span><br><span class="line">LOGI(<span class="string">"a"</span>, &amp;a)</span><br><span class="line">LOGI(<span class="string">"b"</span>, &amp;b)</span><br><span class="line"></span><br><span class="line">r = b;</span><br><span class="line">LOGI(<span class="string">"r"</span>, r)</span><br><span class="line">LOGI(<span class="string">"r"</span>, &amp;r)</span><br><span class="line">LOGI(<span class="string">"a"</span>, &amp;a)</span><br><span class="line">LOGI(<span class="string">"b"</span>, &amp;b)</span><br></pre></td></tr></table></figure><p>如上，最终的打印为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TAG:r || 4</span><br><span class="line">TAG:r || 0x7fffa8aee308</span><br><span class="line">TAG:a || 0x7fffa8aee308</span><br><span class="line">TAG:b || 0x7fffa8aee30c</span><br><span class="line">TAG:r || 5</span><br><span class="line">TAG:r || 0x7fffa8aee308</span><br><span class="line">TAG:a || 0x7fffa8aee308</span><br><span class="line">TAG:b || 0x7fffa8aee30c</span><br></pre></td></tr></table></figure><p></p><p>可以看到，引用<code>r</code>在声明时绑定了int类型的对象<code>a</code>，则其地址值一直跟<code>a</code>一致，无论后面对引用<code>r</code>进行什么操作，都相当于对<code>a</code>进行操作。</p><h2 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h2><blockquote><p>相关链接：<a href="https://vites.app/article/dev/531f17fa.html">C++中的顶层const</a></p></blockquote><p>const引用一般简称为常量引用，意指该引用绑定的是一个常量对象，是一个底层const。</p><p>常量引用不止可以绑定常量对象，也可以绑定常量值。其中特殊的一点是，还可以绑定非常量对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>如上，常量引用<code>r1</code>可以绑定非常量对象<code>i</code>。常量引用本身是无法再进行修改操作的，但其绑定的非常量对象可以进行修改。</p><p>特别注意的是，比如数值型的变量之间可以相互赋值，虽然会丢失精度，如double型的值直接可以直接赋值到int类型上。因此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line">LOGI(<span class="string">"&amp;a"</span>,&amp;a)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = a;</span><br><span class="line">LOGI(<span class="string">"r"</span>,r)</span><br><span class="line">LOGI(<span class="string">"&amp;r"</span>,&amp;r)</span><br><span class="line">a = <span class="number">5.14</span>;</span><br><span class="line">LOGI(<span class="string">"r"</span>,r)</span><br><span class="line">LOGI(<span class="string">"&amp;r"</span>,&amp;r)</span><br></pre></td></tr></table></figure><p>如上，最终的打印为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TAG:&amp;a || 0x7ffcb2c98968</span><br><span class="line">TAG:r || 3</span><br><span class="line">TAG:&amp;r || 0x7ffcb2c98964</span><br><span class="line">TAG:r || 3</span><br><span class="line">TAG:&amp;r || 0x7ffcb2c98964</span><br></pre></td></tr></table></figure><p>可以看到，虽然表面上int型的常量引用<code>r</code>可以“绑定”double型对象<code>a</code>，但实际他们的地址并不相同。主要原因是编译器为了确保引用<code>r</code>可以绑定一个整数，在编译时增加了一个<strong>临时量</strong>对象。C++ Primer中的描述为：</p><blockquote><p>所谓的临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。</p></blockquote><p>因此，经过编译器编译后的代码可以理解为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3.1f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = temp;</span><br></pre></td></tr></table></figure><p>因此，上面打印的引用<code>r</code>的地址值为临时量对象的地址值，而改变对象<code>a</code>的值，也不会改变引用<code>r</code>所绑定的对象的值。</p><h2 id="取地址操作符"><a href="#取地址操作符" class="headerlink" title="取地址操作符"></a>取地址操作符</h2><p><code>&amp;</code>用在已经声明的对象前面（注意不是在声明时使用），表示获取该对象的地址。这个比较常用，就不细说了。</p><h1 id=""><a href="#" class="headerlink" title="*"></a>*</h1><p><code>*</code>和<code>&amp;</code>一样有两种用法，分别是在定义变量时声明为指针和使用变量时作为解引用符。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>引用C++ Primer中对指针的定义：</p><blockquote><p>指针(Pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的简直访问。然而指针与引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p></blockquote><p>简单来说，指针是一种类型，用于指向另一个对象；而引用只是绑定对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> *p = i;</span><br><span class="line"><span class="keyword">int</span> *pp;</span><br></pre></td></tr></table></figure><p>声明一个指针，只需要在声明变量时加入<code>*</code>即可。</p><h2 id="解引用符"><a href="#解引用符" class="headerlink" title="解引用符"></a>解引用符</h2><p><code>*</code>用在对象前面即表示为解引用符，解引用符只能用在指针类型的变量上。</p><p>C++ Primer中的定义：</p><blockquote><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值。</p></blockquote></div><div class="columns is-variable is-1 is-multiline is-mobile"><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/C/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> C++</a></span></div><div class="columns is-mobile is-multiline article-nav"> <span class="column is-12-mobile is-half-desktop article-nav-prev"><a href="/article/dev/1f85290d.html">setLayoutParams和onMeasure</a></span> <span class="column is-12-mobile is-half-desktop article-nav-next"><a href="/article/dev/6bd07504.html">C++中typedef和指针结合时理解</a></span></div><script>setArticleTime("article-time-42923d2a","Thu Aug 01 2019 20:22:52 GMT+0800")</script></article><div class="sharebox"><div class="addthis_inline_share_toolbox"></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5af91abd06c0d49f"></script></div><div class="comments"><h3 class="title is-4">评论</h3><div id="valine-thread"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"GUCbjfNG4dzXp1OK5wLej8sB-gzGzoHsz",app_key:"8g2nRqttkIwqsgHOOsEzRvX2",placeholder:"我有一言，请诸位静听",avatar:"identicon"})</script></div></div></section><footer class="footer"><div class="container"><div class="columns content"><div class="column is-narrow has-text-centered"> &copy; 2022 Vincent Tam&nbsp; Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a></div><div class="column is-hidden-mobile"></div></div></div></footer><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"></script><script>$(document).ready(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script>window.FontAwesomeConfig={searchPseudoElements:!0}</script><script>window.MathJax={chtml:{matchFontHeight:!1},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"},tex:{autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script src="//cdn.bootcdn.net/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script><script>!function(e){e(document).ready(function(){"function"==typeof e.fn.lightGallery&&e(".article.gallery").lightGallery({selector:".gallery-item"}),"function"==typeof e.fn.justifiedGallery&&e(".justified-gallery").justifiedGallery()})}(jQuery)</script><script src="/js/script.js"></script><div class="searchbox ins-search"><div class="searchbox-mask"></div><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></body></html>
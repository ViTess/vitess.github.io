<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>The ABC of Dart Part 3 - 类 - Debug表演艺术家</title><meta name="description" content="ViTe&#39;s Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="QQchFmWKLy"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"><link rel="icon" href="https://vites.app/images/favicon.png"><script src="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/themes/black/pace-theme-flash.css" rel="stylesheet"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/bulma/0.6.2/css/bulma.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/lightgallery/1.6.10/css/lightgallery.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"><script src="//cdn.bootcdn.net/ajax/libs/moment.js/2.22.1/moment.min.js"></script><script>function setArticleTime(e,t){var d=moment(t),n=moment().diff(d,"days",!0);document.getElementsByClassName(e)[0].innerHTML=7<n?d.format("YYYY年MM月DD日 HH:mm:ss"):d.fromNow()}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?t(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],t):t(e.moment)}(this,function(e){"use strict";return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:11<=e?e:e+12},meridiem:function(e,t,d){var n=100*e+t;return n<600?"凌晨":n<900?"早上":n<1130?"上午":n<1230?"中午":n<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s内",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?40c23cf929965ff7dcc44d0e695ed794";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a class="navbar-item" href="/" style="padding:0 3rem 0 1rem"><img src="/images/logo.png" alt=""></a><div class="navbar-burger"><span></span><span></span><span></span></div></div><div class="navbar-menu navbar-start"> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-menu navbar-end"><a class="navbar-item search" href="javascript:;"><i class="fas fa-search"></i></a><div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only"><a class="navbar-item toc"><i class="fa fa-list"></i></a><div class="navbar-dropdown is-right"> <a class="navbar-item" href="#构造函数">1 构造函数</a><hr class="navbar-divider"> <a class="navbar-item" href="#没有函数重载！">2 没有函数重载！</a><hr class="navbar-divider"> <a class="navbar-item" href="#命名构造函数">3 命名构造函数</a><hr class="navbar-divider"> <a class="navbar-item" href="#生成对象">4 生成对象</a><hr class="navbar-divider"> <a class="navbar-item" href="#构造函数传参">5 构造函数传参</a><hr class="navbar-divider"> <a class="navbar-item" href="#生成不可变的对象">6 生成不可变的对象</a><hr class="navbar-divider"> <a class="navbar-item" href="#Getter-amp-Setter">7 Getter &amp; Setter</a><hr class="navbar-divider"> <a class="navbar-item" href="#extends-amp-implements">8 extends &amp; implements</a><hr class="navbar-divider"> <a class="navbar-item" href="#抽象类">9 抽象类</a><hr class="navbar-divider"> <a class="navbar-item" href="#mixin-混合">10 mixin(混合)</a><hr class="navbar-divider"> <a class="navbar-item" href="#工厂构造函数">11 工厂构造函数</a></div></div><a class="navbar-item" href="https://github.com/vitess"><i class="fab fa-github"></i></a><a class="navbar-item" href="https://weibo.com/2373803622"><i class="fab fa-weibo"></i></a><a class="navbar-item" href="mailto:vite@outlook.com"><i class="fa fa-envelope-square"></i></a></div></div></nav><section class="section"><div class="container"><article class="article content gallery" itemscope itemprop="blogPost"><h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name"> The ABC of Dart Part 3 - 类</h1><div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile"><span class="column is-narrow"><time class="article-time-bd58250c" datetime="2018-06-11T03:27:06.000Z" itemprop="datePublished"></time></span><span class="column is-narrow article-category"><i class="far fa-folder"></i> <a class="article-category-link" href="/categories/dev/">开发</a></span></div><div class="article-entry is-size-6-mobile" itemprop="articleBody"><p>前面说到<code>Dart</code>中一切皆为对象。而所有对象都是类的实例，并且所有类都为<code>Object</code>的子类。</p><p>和其他语言一样，类也是用<code>class</code>关键字作为声明。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><code>Dart</code>具有构造函数，跟<code>C++</code>不一样，没有析构函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    TestClass()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是标准写法。如果没有显示声明构造函数，类默认有一个无参数的构造函数。另外，<code>Dart</code>针对构造函数中没有内容的情况时提供了一种简写，比如上述代码可以简写如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    TestClass(); <span class="comment">//简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="没有函数重载！"><a href="#没有函数重载！" class="headerlink" title="没有函数重载！"></a>没有函数重载！</h1><p><code>Dart</code>中没有函数重载功能，当在同一个类中定义了一个名为<code>func</code>的函数后，后面不能再定义一个名字相同、但返回类型和参数类型不同的函数。</p><p>同样的，因为没有函数重载，构造函数也不存在重载，即当一个类中定义了一个构造函数后，就无法再定义一个相同名字、但构造不同的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    TestClass();</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="built_in">int</span> i)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，IDE会提示错误，不允许编译。</p><h1 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h1><p>那么，如果一个类确实需要多个构造函数时该怎么做呢？<code>Dart</code>提供了<strong>命名构造函数</strong>，即构造函数可以定义不同的名字，通过<code>.</code>来实现，如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    TestClass(); <span class="comment">//默认的构造函数</span></span><br><span class="line">    </span><br><span class="line">    TestClass.second(<span class="built_in">int</span> i)&#123; <span class="comment">//自定义命名的构造函数</span></span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<strong>命名构造函数</strong>，可以实现如其他语言中类的构造函数重载的功能。</p><h1 id="生成对象"><a href="#生成对象" class="headerlink" title="生成对象"></a>生成对象</h1><p>生成一个类的实例对象，通过<code>new</code>关键字实现，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> TestClass(); <span class="comment">//默认的构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> TestClass.second(<span class="number">1</span>); <span class="comment">//自定义命名的构造函数</span></span><br></pre></td></tr></table></figure><h1 id="构造函数传参"><a href="#构造函数传参" class="headerlink" title="构造函数传参"></a>构造函数传参</h1><p><code>Dart</code>中的类和<code>Java</code>一样，通过<code>this</code>关键字指向实例自身，因此标准的构造函数传参和<code>Java</code>一致：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> param;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="built_in">int</span> param)&#123;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<code>Dart</code>在传参上也提供了简写，也是通过<code>this</code>关键字实现的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> param1, param2;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="keyword">this</span>.param1, <span class="keyword">this</span>.param2)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，这样调用构造函数将自动把值传递给类的变量。如果构造函数只用于传递值，而不需要在里面做其他逻辑，则可以这样简写：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> param1, param2;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="keyword">this</span>.param1, <span class="keyword">this</span>.param2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，在构造函数中也可以使用可选参数来定义参数。</p></blockquote><h1 id="生成不可变的对象"><a href="#生成不可变的对象" class="headerlink" title="生成不可变的对象"></a>生成不可变的对象</h1><p><code>Dart</code>中可以用<code>const</code>修饰构造函数，这样通过该构造函数构建出来的对象是不可变的对象，此类对象可以赋值给<code>final</code>或<code>const</code>修饰的常量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> p1, p2;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="keyword">this</span>.p1, <span class="keyword">this</span>.p2)&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> TestClass.second(<span class="keyword">this</span>.p1, <span class="keyword">this</span>.p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成对象</span></span><br><span class="line"><span class="comment">//const TestClass obj1 = new TestClass(1,2); //报错</span></span><br><span class="line"><span class="keyword">const</span> TestClass obj1 = <span class="keyword">const</span> TestClass.second(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">final</span> TestClass obj2 = <span class="keyword">const</span> TestClass.second(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//(2)</span></span><br><span class="line"><span class="keyword">final</span> TestClass obj3 = <span class="keyword">new</span> TestClass(<span class="number">1</span>,<span class="number">2</span>);          <span class="comment">//(3)</span></span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="keyword">new</span> TestClass.second(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">//(4)</span></span><br></pre></td></tr></table></figure><p>如上，除了注释掉的那一行会报错的以外，(1)、(2)、(3)、(4)行都可以编译运行。其中，被<code>const</code>所修饰的常量，赋值时必须用<code>const</code>来生成对象，不能用<code>new</code>；反过来，<code>final</code>所修饰的对象，用<code>const</code>或者<code>new</code>来生成对象都可以。</p><p>需要注意的是，使用<code>const</code>修饰构造函数时，其对应的类中的所有成员变量都必须用<code>final</code>修饰，并且不允许有函数body（即大括号<code>{}</code>包裹的逻辑语句）。</p><p>同时，由于成员变量被<code>final</code>修饰，所以构造函数必须用简写的模式来给变量赋值。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> p1;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">int</span> p2;</span><br><span class="line">    </span><br><span class="line">    TestClass(<span class="built_in">int</span> a ,<span class="keyword">this</span>.p2)&#123;</span><br><span class="line">        p1 = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，因为变量<code>p2</code>被修饰为<code>final</code>，所以必须用简写模式赋值。</p><h1 id="Getter-amp-Setter"><a href="#Getter-amp-Setter" class="headerlink" title="Getter &amp; Setter"></a>Getter &amp; Setter</h1><p>在<code>Dart</code>中，类中的成员变量、成员函数不存在<em>访问权限</em>这个概念，像<code>Java</code>中的<code>private</code>、<code>public</code>之类的并不存在。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> p1;</span><br><span class="line">    <span class="built_in">int</span> p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">testClass.p1 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print</span>(testClass.p2);</span><br></pre></td></tr></table></figure><p>如上述代码中，任何人只要生成了类的实例对象，就可以通过对象来访问、修改这个类的成员变量。但这里又和其他的语言有点不同——在<code>Dart</code>中，之所以可以直接调用、修改实例的变量，是因为在<code>Dart</code>中类的所有成员变量默认有其<strong>隐式的相同名字</strong>的Getter和Setter，如果变量被<code>final</code>或<code>const</code>修饰，那么只有Getter没有Setter。</p><p>如果要显式定义某个变量的Getter或者Setter，则分别需要用<code>get</code>和<code>set</code>关键字来实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> p1;</span><br><span class="line">    <span class="built_in">int</span> p2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int get p1 =&gt; p1;//报错</span></span><br><span class="line">    <span class="comment">//set p1(int i) =&gt; p1 = i;//报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">get</span> myP1 =&gt; p1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">get</span> myP2&#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> myP1(<span class="built_in">int</span> i) =&gt; p1 = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> myP2(<span class="built_in">int</span> i)&#123;</span><br><span class="line">        p2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">var</span> testClass = <span class="keyword">new</span> TestClass();</span><br><span class="line">testClass.myP1 = <span class="number">1</span>; <span class="comment">//调用Setter方法myP1</span></span><br><span class="line">testClass.myP2 = <span class="number">2</span>; <span class="comment">//调用Setter方法myP2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(testClass.myP1); <span class="comment">//调用Getter方法myP1，打印1</span></span><br><span class="line"><span class="built_in">print</span>(testClass.myP2); <span class="comment">//调用Getter方法myP2，打印2</span></span><br></pre></td></tr></table></figure><p>如上述代码，Getter和Setter的方法名可以相同。注意<code>get</code>修饰的Getter方法不能有<code>()</code>。<code>set</code>修饰的Setter方法后面带有<code>()</code>，但调用时不能用<code>testClass.myP1(1)</code>这种方式，而是用<code>=</code>来调用Setter方法。</p><p>前面说到，每个成员变量有其隐式的Getter和Setter，所以当我们自定义Getter、Setter时，命名不能用和成员变量一样的名字。</p><h1 id="extends-amp-implements"><a href="#extends-amp-implements" class="headerlink" title="extends &amp; implements"></a>extends &amp; implements</h1><p>类的继承通过<code>extends</code>关键字来实现，基本实现和操作跟<code>Java</code>大致相同。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> func2()&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="keyword">super</span>.func1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，<code>TestClass</code>集成了<code>BaseClass</code>，因此可以选择性地改写<code>BaseClass</code>的方法。</p><p>而实现接口则通过<code>implements</code>关键字实现，与<code>Java</code>不同的是<code>dart</code>没有<code>interface</code>这个关键字，因为每一个类都是一个<strong>隐式接口</strong>。以上面的<code>BaseClass</code>为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> <span class="keyword">implements</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> func2()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TestClass2</code>通过<code>implements</code>实现了<code>BaseClass</code>内定义的方法<code>func1()</code>、<code>func2()</code>，虽然<code>BaseClass</code>在<code>func1()</code>、<code>func2()</code>里都有定义内容，但通过<code>implements</code>实现后，<code>TestClass2</code>并不会像<code>extends</code>一样默认执行<code>BaseClass</code>的方法。</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类通过<code>abstract</code>关键字修饰类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> func()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> <span class="keyword">implements</span> <span class="title">BaseClass</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> func()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，抽象类在继承和实现接口上并没有什么区别，都是强制要求实现抽象类中定义的函数。</p><p>和<code>Java</code>不同，<code>dart</code>只有抽象类，没有抽象方法。</p><h1 id="mixin-混合"><a href="#mixin-混合" class="headerlink" title="mixin(混合)"></a>mixin(混合)</h1><p>我们知道，实现接口时可以<code>implements</code>多个接口，每个接口用逗号隔开：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> <span class="keyword">implements</span> <span class="title">BaseClass1</span>,<span class="title">BaseClass2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而继承只能继承一个类。某些时候，可能我们希望能继承多个类，不同的方法用不同类的实现方式——这时候，就可以使用<code>dart</code>提供的mixin(混合)模式。</p><p>mixin通过<code>with</code>关键字来实现。举个例子，现在分别有两个类<code>ClassA</code>和<code>ClassB</code>，通过这两个类组合成一个新的类<code>ClassC</code>，则表现为：</p><blockquote><p>ClassC = ClassA with ClassB</p></blockquote><p>假设<code>ClassA</code>中所有方法的集合为\(F_{A}\)，<code>ClassB</code>中所有方法的集合为\(F_{B}\)，<code>ClassC</code>中所有方法的集合为\(F_{C}\)，则可理解为：</p><p>$$F_{C}=F_{B} \cup (F_{A}-F_{B})$$</p><p>即<code>ClassC</code>中的所有方法为<code>ClassA</code>和<code>ClassB</code>的方法的集合，如果<code>ClassA</code>和<code>ClassB</code>中有重复的方法，则取<code>ClassB</code>的实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassA func1"</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> func2()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassA func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassB func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> = <span class="title">ClassA</span> <span class="title">with</span> <span class="title">ClassB</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">    ClassC classC = <span class="keyword">new</span> ClassC();</span><br><span class="line">    classC.func1();<span class="comment">//输出ClassB func1</span></span><br><span class="line">    classC.func2();<span class="comment">//输出ClassA func2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>with</code>关键字也可以通过逗号混合多个类。例如，目前分别有<code>ClassA</code>、<code>ClassB</code>、<code>ClassC</code>三个类，将该三个类组合成一个新类<code>ClassD</code>：</p><blockquote><p>ClassD = ClassA with ClassB,ClassC</p></blockquote><p>这就相当于按顺序调用<code>with</code>：</p><blockquote><p>ClassD = (ClassA with ClassB) with ClassC</p></blockquote><p>例子如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassA func1"</span>);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> func2()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassA func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> func3()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassA func3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassB func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> func2()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassB func2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> func1()&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"ClassC func1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassD</span> = <span class="title">ClassA</span> <span class="title">with</span> <span class="title">ClassB</span>,<span class="title">ClassC</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">    ClassD classD = <span class="keyword">new</span> ClassD();</span><br><span class="line">    classD.func1();<span class="comment">//输出ClassC func1</span></span><br><span class="line">    classD.func2();<span class="comment">//输出ClassB func2</span></span><br><span class="line">    classD.func3();<span class="comment">//输出ClassA func3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h1><p>使用<code>factory</code>修饰构造函数，具体意义不多说了，网上给出的例子都是方便调用者可以使用同一个对象，并不是单纯意义上的工厂设计模式。</p></div><div class="columns is-variable is-1 is-multiline is-mobile"><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Dart/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> Dart</a></span></div><div class="columns is-mobile is-multiline article-nav"> <span class="column is-12-mobile is-half-desktop article-nav-prev"><a href="/article/dev/b6a55dfb.html">AudioTrack播放卡顿的现象</a></span> <span class="column is-12-mobile is-half-desktop article-nav-next"><a href="/article/dev/ca5f159a.html">The ABC of Dart Part 2 - 函数</a></span></div><script>setArticleTime("article-time-bd58250c","Mon Jun 11 2018 11:27:06 GMT+0800")</script></article><div class="sharebox"><div class="addthis_inline_share_toolbox"></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5af91abd06c0d49f"></script></div><div class="comments"><h3 class="title is-4">评论</h3><div id="valine-thread"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"GUCbjfNG4dzXp1OK5wLej8sB-gzGzoHsz",app_key:"8g2nRqttkIwqsgHOOsEzRvX2",placeholder:"我有一言，请诸位静听",avatar:"identicon"})</script></div></div></section><footer class="footer"><div class="container"><div class="columns content"><div class="column is-narrow has-text-centered"> &copy; 2022 Vincent Tam&nbsp; Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a></div><div class="column is-hidden-mobile"></div></div></div></footer><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"></script><script>$(document).ready(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script>window.FontAwesomeConfig={searchPseudoElements:!0}</script><script>window.MathJax={chtml:{matchFontHeight:!1},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"},tex:{autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script src="//cdn.bootcdn.net/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script><script>!function(e){e(document).ready(function(){"function"==typeof e.fn.lightGallery&&e(".article.gallery").lightGallery({selector:".gallery-item"}),"function"==typeof e.fn.justifiedGallery&&e(".justified-gallery").justifiedGallery()})}(jQuery)</script><script src="/js/script.js"></script><div class="searchbox ins-search"><div class="searchbox-mask"></div><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></body></html>
<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>RxJava的一些线程问题 - Debug表演艺术家</title><meta name="description" content="ViTe&#39;s Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="QQchFmWKLy"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"><link rel="icon" href="https://vites.app/images/favicon.png"><script src="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/themes/black/pace-theme-flash.css" rel="stylesheet"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/bulma/0.6.2/css/bulma.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/lightgallery/1.6.10/css/lightgallery.min.css"><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"><script src="//cdn.bootcdn.net/ajax/libs/moment.js/2.22.1/moment.min.js"></script><script>function setArticleTime(e,t){var d=moment(t),n=moment().diff(d,"days",!0);document.getElementsByClassName(e)[0].innerHTML=7<n?d.format("YYYY年MM月DD日 HH:mm:ss"):d.fromNow()}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?t(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],t):t(e.moment)}(this,function(e){"use strict";return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:11<=e?e:e+12},meridiem:function(e,t,d){var n=100*e+t;return n<600?"凌晨":n<900?"早上":n<1130?"上午":n<1230?"中午":n<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s内",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?40c23cf929965ff7dcc44d0e695ed794";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a class="navbar-item" href="/" style="padding:0 3rem 0 1rem"><img src="/images/logo.png" alt=""></a><div class="navbar-burger"><span></span><span></span><span></span></div></div><div class="navbar-menu navbar-start"> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-menu navbar-end"><a class="navbar-item search" href="javascript:;"><i class="fas fa-search"></i></a><div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only"><a class="navbar-item toc"><i class="fa fa-list"></i></a><div class="navbar-dropdown is-right"> <a class="navbar-item" href="#坑1：Schedulers-computation">1 坑1：Schedulers.computation()</a><hr class="navbar-divider"> <a class="navbar-item" href="#坑2：Schedulers-trampoline">2 坑2：Schedulers.trampoline()</a><hr class="navbar-divider"> <a class="navbar-item" href="#总结">3 总结</a></div></div><a class="navbar-item" href="https://github.com/vitess"><i class="fab fa-github"></i></a><a class="navbar-item" href="https://weibo.com/2373803622"><i class="fab fa-weibo"></i></a><a class="navbar-item" href="mailto:vite@outlook.com"><i class="fa fa-envelope-square"></i></a></div></div></nav><section class="section"><div class="container"><article class="article content gallery" itemscope itemprop="blogPost"><h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name"> RxJava的一些线程问题</h1><div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile"><span class="column is-narrow"><time class="article-time-64bbb612" datetime="2019-04-19T10:29:36.000Z" itemprop="datePublished"></time></span><span class="column is-narrow article-category"><i class="far fa-folder"></i> <a class="article-category-link" href="/categories/dev/">开发</a></span></div><div class="article-entry is-size-6-mobile" itemprop="articleBody"><p>RxJava上提供了一系列的线程池，用起来确实很方便，不过随便用的话很容易遇到坑。</p><a id="more"></a><h1 id="坑1：Schedulers-computation"><a href="#坑1：Schedulers-computation" class="headerlink" title="坑1：Schedulers.computation()"></a>坑1：Schedulers.computation()</h1><p><code>Schedulers.computation()</code>在RxJava中定义为用于计算任务的线程池，其线程数等于当前运行环境的CPU核心数。比如在我的华为Mate9 Pro中，其线程数为8。</p><p>事实上RxJava中很多操作符都默认使用<code>computation()</code>线程池，比如<code>timer()</code>、<code>interval()</code>、<code>intervalRange()</code>等。</p><p>最近有同事跟我说，使用<code>timer()</code>、<code>interval()</code>的时候，有几率不执行。其实根本原因是其他地方也使用了<code>computation()</code>中的线程，并且其线程池中的所有线程都被占用了，必须等到<code>computation()</code>中有空闲的线程后才执行后面的任务。</p><p>所以使用到默认<code>computation()</code>线程的操作符时，最好直接设置<code>io()</code>或者<code>newThread()</code>线程。</p><h1 id="坑2：Schedulers-trampoline"><a href="#坑2：Schedulers-trampoline" class="headerlink" title="坑2：Schedulers.trampoline()"></a>坑2：Schedulers.trampoline()</h1><p><code>Schedulers.trampoline()</code>在RxJava中定义为在当前线程中执行，如果同时存在多个任务，则根据FIFO原则执行任务。</p><p>上面说到有同事遇到<code>timer()</code>不执行的情况，所以他实际操作的时候使用这种写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(<span class="number">5</span>, TimeUnit.MINUTES, Schedulers.trampoline())</span><br><span class="line">          .subscribeOn(Schedulers.io())</span><br><span class="line">          .observerOn(AndroidSchedulers.mainThread())</span><br><span class="line">          .subscribe(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//TODO</span></span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure><p>同时由于项目中设置了<code>RxJavaPlugins.setErrorHandler()</code>，所以一开始执行没什么问题。后来我去掉了这个设置之后，就开始频繁崩溃了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">io.reactivex.exceptions.UndeliverableException: java.lang.InterruptedException</span><br><span class="line">at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:349)</span><br><span class="line">at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:64)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:38)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:11040)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)</span><br><span class="line">at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)</span><br><span class="line">at java.lang.Thread.run(Thread.java:764)</span><br><span class="line">Caused by: java.lang.InterruptedException</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:373)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:395)</span><br><span class="line">at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:60)</span><br><span class="line">... 11 more</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at java.lang.Thread.sleep(Thread.java:373)</span><br><span class="line">at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:395)</span><br><span class="line">at io.reactivex.internal.schedulers.TrampolineScheduler.scheduleDirect(TrampolineScheduler.java:60)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableTimer.subscribeActual(ObservableTimer.java:38)</span><br><span class="line">at io.reactivex.Observable.subscribe(Observable.java:11040)</span><br><span class="line">at io.reactivex.internal.operators.observable.ObservableSubscribeOn$SubscribeTask.run(ObservableSubscribeOn.java:96)</span><br><span class="line">at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:463)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)</span><br><span class="line">at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)</span><br><span class="line">at java.lang.Thread.run(Thread.java:764)</span><br></pre></td></tr></table></figure><p>要理解为什么会崩溃，首先要从<code>timer()</code>的实现去入手：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">timer</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(unit, <span class="string">"unit is null"</span>);</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableTimer(Math.max(delay, <span class="number">0L</span>), unit, scheduler));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实现为<code>ObservableTimer</code>，只需要看其中的<code>subscribeActual()</code>方法实现即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> Long&gt; s)</span> </span>&#123;</span><br><span class="line">    TimerObserver ios = <span class="keyword">new</span> TimerObserver(s);</span><br><span class="line">    s.onSubscribe(ios);</span><br><span class="line"></span><br><span class="line">    Disposable d = scheduler.scheduleDirect(ios, delay, unit);</span><br><span class="line"></span><br><span class="line">    ios.setResource(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实现为调用传入的<code>Scheduler</code>的<code>scheduleDirect()</code>方法。上面代码中传入的为<code>Schedulers.trampoline()</code>，其<code>scheduleDirect()</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unit.sleep(delay);</span><br><span class="line">        RxJavaPlugins.onSchedule(run).run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        RxJavaPlugins.onError(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码表示当<code>timer()</code>传入<code>Schedulers.trampoline()</code>时，其延时效果通过当前线程的<code>sleep()</code>实现。</p><p>作为对比，看一下<code>Schedulers.computation()</code>的<code>scheduleDirect()</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    PoolWorker w = pool.get().getEventLoop();</span><br><span class="line">    <span class="keyword">return</span> w.scheduleDirect(run, delay, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PoolWorker</code>继承了<code>NewThreadWorker</code>，其<code>scheduleDirect()</code>的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    ScheduledDirectTask task = <span class="keyword">new</span> ScheduledDirectTask(RxJavaPlugins.onSchedule(run));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Future&lt;?&gt; f;</span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            f = executor.submit(task);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = executor.schedule(task, delayTime, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        task.setFuture(f);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">        RxJavaPlugins.onError(ex);</span><br><span class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的<code>executor</code>为线程池的实例，所以当<code>timer()</code>传入<code>Schedulers.computation()</code>时，其延时效果通过线程池的任务计划调度执行。</p><p>再回头看出现的崩溃，经试验，其崩溃的时机在于<code>timer()</code>还未执行，然后手动调用<code>dispose()</code>取消其执行时出现的。所以还需要看下<code>dispose()</code>的具体实现，其被调用时实际是调用<code>ScheduledRunnable</code>的<code>dispose()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Object o = get(FUTURE_INDEX);</span><br><span class="line">        <span class="keyword">if</span> (o == DONE || o == SYNC_DISPOSED || o == ASYNC_DISPOSED) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> async = get(THREAD_INDEX) != Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(FUTURE_INDEX, o, async ? ASYNC_DISPOSED : SYNC_DISPOSED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((Future&lt;?&gt;)o).cancel(async);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Object o = get(PARENT_INDEX);</span><br><span class="line">        <span class="keyword">if</span> (o == DONE || o == PARENT_DISPOSED || o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(PARENT_INDEX, o, PARENT_DISPOSED)) &#123;</span><br><span class="line">            ((DisposableContainer)o).delete(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即最终的实现是通过调用线程池中对应任务的<code>Future</code>的<code>cancel()</code>方法，在当前例子中其<code>cancel()</code>方法传入的为true，即会执行中断线程的操作。</p><p>回到开头的例子，在传入<code>Schedulers.trampoline()</code>后，又通过<code>subscribeOn()</code>将任务放入<code>Schdulers.io()</code>的线程中执行，即其在<code>io()</code>线程中调用了<code>sleep()</code>方法。紧接着在调用<code>dispose()</code>方法时，将当前<code>io()</code>线程的<code>Future</code>取出并执行<code>cancel(true)</code>。如果当前线程中正在<code>sleep()</code>，则会直接抛出InterruptedException异常来中断操作。而在<code>trampoline()</code>的内部实现中，InterruptedException不会被截获到原来的Observable的onError中，而是直接抛到<code>RxJavaPlugins</code>的<code>onError()</code>中处理，所以在取消设置<code>RxJavaPlugins.setErrorHandler()</code>后，就会出现崩溃。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>使用默认<code>computation()</code>线程池实现的操作符时，最后另外设置线程进去。</li><li>尽量不要使用<code>trampoline()</code>来实现延时操作</li><li>日常开发时不要设置<code>RxJavaPlugins.setErrorHandler()</code></li><li>线上正式包中最好设置<code>RxJavaPlugins.setErrorHandler()</code></li></ol></div><div class="columns is-variable is-1 is-multiline is-mobile"><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Android/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> Android</a></span><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/RxJava/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> RxJava</a></span></div><div class="columns is-mobile is-multiline article-nav"> <span class="column is-12-mobile is-half-desktop article-nav-prev"><a href="/article/dev/c04b6b0b.html">MediaCodec编码摄像头数据时控制帧率的方法</a></span> <span class="column is-12-mobile is-half-desktop article-nav-next"><a href="/article/dev/b35ace79.html">Flutter先导篇</a></span></div><script>setArticleTime("article-time-64bbb612","Fri Apr 19 2019 18:29:36 GMT+0800")</script></article><div class="sharebox"><div class="addthis_inline_share_toolbox"></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5af91abd06c0d49f"></script></div><div class="comments"><h3 class="title is-4">评论</h3><div id="valine-thread"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"GUCbjfNG4dzXp1OK5wLej8sB-gzGzoHsz",app_key:"8g2nRqttkIwqsgHOOsEzRvX2",placeholder:"我有一言，请诸位静听",avatar:"identicon"})</script></div></div></section><footer class="footer"><div class="container"><div class="columns content"><div class="column is-narrow has-text-centered"> &copy; 2022 Vincent Tam&nbsp; Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a></div><div class="column is-hidden-mobile"></div></div></div></footer><script src="//cdn.bootcdn.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="//cdn.bootcdn.net/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.css"></script><script>$(document).ready(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script>window.FontAwesomeConfig={searchPseudoElements:!0}</script><script>window.MathJax={chtml:{matchFontHeight:!1},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"},tex:{autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script src="//cdn.bootcdn.net/ajax/libs/mathjax/3.0.5/es5/tex-mml-chtml.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script><script>!function(e){e(document).ready(function(){"function"==typeof e.fn.lightGallery&&e(".article.gallery").lightGallery({selector:".gallery-item"}),"function"==typeof e.fn.justifiedGallery&&e(".justified-gallery").justifiedGallery()})}(jQuery)</script><script src="/js/script.js"></script><div class="searchbox ins-search"><div class="searchbox-mask"></div><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></body></html>
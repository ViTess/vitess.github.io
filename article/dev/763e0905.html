<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>OpenGLES开发透明通道视频备忘录 - Debug表演艺术家</title><meta name="description" content="ViTe&#39;s Blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu-site-verification" content="QQchFmWKLy"><link rel="stylesheet" href="//cdn.bootcss.com/outdated-browser/1.1.5/outdatedbrowser.min.css"><link rel="icon" href="https://vites.app/images/favicon.png"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><link rel="stylesheet" href="//fonts.lug.ustc.edu.cn/css?family=Ovo|Source+Code+Pro"><link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.6.2/css/bulma.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/lightgallery/1.6.10/css/lightgallery.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous"><script src="//cdn.bootcss.com/moment.js/2.22.1/moment.min.js"></script><script>function setArticleTime(e,t){var d=moment(t),n=moment().diff(d,"days",!0);document.getElementsByClassName(e)[0].innerHTML=7<n?d.format("YYYY年MM月DD日 HH:mm:ss"):d.fromNow()}!function(e,t){"object"==typeof exports&&"undefined"!=typeof module&&"function"==typeof require?t(require("../moment")):"function"==typeof define&&define.amd?define(["../moment"],t):t(e.moment)}(this,function(e){"use strict";return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:11<=e?e:e+12},meridiem:function(e,t,d){var n=100*e+t;return n<600?"凌晨":n<900?"早上":n<1130?"上午":n<1230?"中午":n<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s内",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?40c23cf929965ff7dcc44d0e695ed794";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation"><div class="container"><div class="navbar-brand"> <a class="navbar-item" href="/" style="padding:0 3rem 0 1rem"><img src="/images/logo.png" alt=""></a><div class="navbar-burger"><span></span><span></span><span></span></div></div><div class="navbar-menu navbar-start"> <a class="navbar-item" href="/archives">Archives</a> <a class="navbar-item" href="/categories">Categories</a> <a class="navbar-item" href="/tags">Tags</a> <a class="navbar-item" href="/about">About</a></div><div class="navbar-menu navbar-end"><a class="navbar-item search" href="javascript:;"><i class="fas fa-search"></i></a><div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only"><a class="navbar-item toc"><i class="fa fa-list"></i></a><div class="navbar-dropdown is-right"> <a class="navbar-item" href="#1-像素采样位置偏差">0.1 1.像素采样位置偏差</a> <a class="navbar-item" href="#线性过滤和最临近过滤">0.1.1 线性过滤和最临近过滤</a> <a class="navbar-item" href="#texelFetch">0.1.2 texelFetch</a> <a class="navbar-item" href="#H264硬解码的宏块与SurfaceTexture的变换矩阵">0.1.3 H264硬解码的宏块与SurfaceTexture的变换矩阵</a> <a class="navbar-item" href="#2-SurfaceTexture销毁问题">0.2 2.SurfaceTexture销毁问题</a> <a class="navbar-item" href="#3-Android4-4的兼容性问题">0.3 3.Android4.4的兼容性问题</a></div></div><a class="navbar-item" href="https://github.com/vitess"><i class="fab fa-github"></i></a><a class="navbar-item" href="https://weibo.com/2373803622"><i class="fab fa-weibo"></i></a><a class="navbar-item" href="mailto:vite@outlook.com"><i class="fa fa-envelope-square"></i></a></div></div></nav><section class="section"><div class="container"><article class="article content gallery" itemscope itemprop="blogPost"><h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name"> OpenGLES开发透明通道视频备忘录</h1><div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile"><span class="column is-narrow"><time class="article-time-763e0905" datetime="2020-04-22T06:47:10.000Z" itemprop="datePublished"></time></span><span class="column is-narrow article-category"><i class="far fa-folder"></i> <a class="article-category-link" href="/categories/dev/">开发</a></span></div><div class="article-entry is-size-6-mobile" itemprop="articleBody"><p>最近在做带透明MP4视频的渲染播放，原理就是视频的一半是只有黑白颜色的透明通道，另一半则是视频原来的画面，只要利用OpenGLES在渲染时提取原来画面的对应位置上的透明通道的透明度，设置到原来画面的像素上，就可以达到播放透明视频的效果。</p><p>原理很简单，实现也不难，但是中间遇到了一些坑，折腾了一段时间才弄明白，主要原因还是基础原理不了解，还是要多学习。</p><a id="more"></a><h2 id="1-像素采样位置偏差"><a href="#1-像素采样位置偏差" class="headerlink" title="1.像素采样位置偏差"></a>1.像素采样位置偏差</h2><p>比如，一个视频的尺寸是1500x750，黑白透明通道在左边，原画面在右边，则实际渲染出来的视频大小应该是750x750。</p><p>OpenGL中，纹理的坐标原点在左下角，所以黑白透明通道的像素采样范围是(0,0)~(749,749)，原画面的像素采样范围是(750,0)~(1499,749)。因为OpenGLES中采样器接收的像素坐标是0~1的浮点型，所以换算过来约等于是(0.0,0.0)~(0.5,1)和(0.5,0.0)~(1.0,1.0)。</p><p>所以刚开始时，我在fragment shader中的写法很简单，将vertex shader传入的纹理坐标的x直接减去0.5，即可获得透明通道的像素值，根据这个值换算成透明度即可。但是在我的Mate30 Pro上，实际效果并不理想，在原画面的物体边缘可以看到有黑边。</p><p>为什么会这样呢？我第一时间认为这是采样问题。</p><h3 id="线性过滤和最临近过滤"><a href="#线性过滤和最临近过滤" class="headerlink" title="线性过滤和最临近过滤"></a>线性过滤和最临近过滤</h3><p>我们称纹理的像素数据为纹素(texel)，由于texel和pixel是无法一一对应的，即无论如何都会存在放大或缩小的情况，这个时候就需要通过对纹理采样来进行纹理像素到屏幕像素的映射。</p><p>具体说明：</p><ul><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/06%20Textures/" target="_blank" rel="noopener">纹理过滤</a></li><li><a href="https://stackoverflow.com/questions/58550323/why-do-we-need-texture-filtering-in-opengl" target="_blank" rel="noopener">Why do we need texture filtering in OpenGL?</a></li><li><a href="https://stackoverflow.com/questions/5879403/opengl-texture-coordinates-in-pixel-space" target="_blank" rel="noopener">OpenGL Texture Coordinates in Pixel Space</a></li><li><a href="https://zhuanlan.zhihu.com/p/82365151" target="_blank" rel="noopener">OpenGL-Texture Filtering(纹理过滤)</a></li></ul><p>所以我们知道，假如OpenGL中的图元和纹理大小完全一致，那么texel和pixel将完全对应，这时候就不需要采样了，但这是不可能的。基于传入的纹理坐标去采样texel时，由于放大或者缩小的关系，可能会采样到目标texel的隔壁去，或者一次采样到多个texel，那么实际渲染到图元上时，要么失真要么锯齿化。</p><p>那么，假如我们对纹理精确采样，是不是就能解决这个问题呢？</p><h3 id="texelFetch"><a href="#texelFetch" class="headerlink" title="texelFetch"></a>texelFetch</h3><p><code>texelFetch</code>是OpenglES 3.0提供的新方法，用于精确采样texel，和<code>texture</code>方法不同，传入的纹理坐标是整型的，因此采样出来的texel也不会经过过滤处理。</p><p>改为<code>texelFetch</code>后，问题确实解决了。但实际效果并不理想，因为没有过滤，在屏幕上的显示是马赛克（锯齿）化的，像素之间的颜色不连贯。</p><p>而且我后来在魅族pro7上测试，发现使用<code>texture</code>方法却不会出现边缘黑边。这说明<code>texelFetch</code>并不是解决方法。</p><h3 id="H264硬解码的宏块与SurfaceTexture的变换矩阵"><a href="#H264硬解码的宏块与SurfaceTexture的变换矩阵" class="headerlink" title="H264硬解码的宏块与SurfaceTexture的变换矩阵"></a>H264硬解码的宏块与SurfaceTexture的变换矩阵</h3><p>一般情况下，在Android中解码视频都会选择硬解码，速度快，效率高，节省资源。硬解码视频无非两种方式，使用<code>MediaCodec</code>手动解码或者<code>MediaPlayer</code>直接播放。两种方式都需要传入一个<code>SurfaceTexture</code>进去。</p><p>先说H264解码，在解码出一幅图像时，图像由N个宏块组成。宏块是H264中编解码的基本单位，一般一个宏块的大小都是16x16。</p><p>在Android上，H264硬编码、解码在一般情况下也是基于这个宏块大小为单位的，所以会有一个16位对齐的要求。在一些机型上，如果编码的视频尺寸没有对齐16位（即无法被16整除），最终出来的视频可能会花屏、绿屏之类的。而解码则不同，假如实际传入的视频不满足16为对齐，最终解码出来的图像尺寸，是原来尺寸除以16后向上取整再乘于16后得到的最临近原来视频尺寸、可被16整除的数值。</p><p>比如上述例子中的1500x750的视频，这个大小是无法被16整除的，所以实际渲染出来的视频大小，其实是：</p><blockquote><p>ceil((1500,750)/16)*16 = (1504,752)</p></blockquote><p>因此，最终解码并传入到纹理单元中的纹理尺寸，其实不是我们以为的1500x750，而是1504x752。前面说到在vertex shader中，传入的纹理坐标范围是(0.0, 1.0)，假如我们不对坐标进行转换处理，最终渲染出来的图像是小于屏幕上设置的控件尺寸的。</p><p>所以我们需要<code>SurfaceTexture</code>的getTransformMatrix()方法，获取解码后经过变换的矩阵。这个变换矩阵的用处在于将传入的纹理采样坐标转换为真正的采样坐标。比如上述的1500x750的视频，解码输出为1504x752，那么变换矩阵是：</p><p>$$S_x=1500\div1504\approx0.997340$$<br>$$S_y=750\div752\approx0.997340$$<br>$$M=\begin{bmatrix}<br>S_x\\<br>S_y\\<br>1<br>\end{bmatrix} \times I_4 = \begin{bmatrix}<br>0.997340&amp;0&amp;0&amp;0\\<br>0&amp;0.997340&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}$$</p><p>也就是说，要采样对应位置的透明通道texel，不能在转换了坐标之后才-0.5，需要先-0.5再进行转换，同时需要考虑到浮点型的精度，因为OpenGLES相对OpenGL的精度更低，无法准确判断一些边界值。</p><p>最终通过上述方法后，渲染出来的画面终于没有了边缘黑边，同时也没有了锯齿马赛克，达到理想效果。至于为什么在魅族pro7上硬解码出来的数据没有对齐16位，这个就不好说了，应该是各家底层有改造过。</p><h2 id="2-SurfaceTexture销毁问题"><a href="#2-SurfaceTexture销毁问题" class="headerlink" title="2.SurfaceTexture销毁问题"></a>2.SurfaceTexture销毁问题</h2><p>根据项目需求，我这边使用的是<code>TextureView</code>，通过内部给出的<code>SurfaceTexture</code>进行OpenGLES绘制。视乎需求，可能会需要长期保存这个<code>SurfaceTexture</code>，但是这样会导致一些问题，比如onDetachedFromWindow()中需要把这个<code>SurfaceTexture</code>释放掉，但是一般没有很好的解决方法。网上推荐的是使用ijkPlayer内的TextureView的保存SurfaceTexture方式，不过比较复杂。</p><p>最好的方式其实是不保存<code>SurfaceTexture</code>，让<code>TextureView</code>自己管理。然后自己在每次触发onSurfaceTextureAvailable()和onSurfaceTextureDestroyed()方法时，再进行对应的逻辑处理。</p><h2 id="3-Android4-4的兼容性问题"><a href="#3-Android4-4的兼容性问题" class="headerlink" title="3.Android4.4的兼容性问题"></a>3.Android4.4的兼容性问题</h2><p>一开始我使用的是<code>MediaCodec</code>自行解码，但发现对应的native内存、graphics内存使用都有点偏高。后面使用<code>MediaPlayer</code>后，发现内存占用都很好，所以就一直使用了。但是发现在Android4.4下有兼容性问题。</p><ol><li>MediaPlayer在离开当前页面时(比如onPause或者onDestroy())必须销毁，不然会出现在新页面无法使用的情况。</li><li>MediaPlayer存在底层状态异常的问题，有的机型一旦出现问题后，必须重启才能继续使用</li><li>MediaPlayer无法在同一界面同时使用多个，具体能同时播放多少个不好说，这个好像有随机性</li></ol><p>为了解决这个问题，最终还是在Android4.4下使用<code>MediaCodec</code>。使用华为荣耀畅玩x4测试，在同一界面上可以稳定同时使用两个进行解码播放，从第三个开始就会出现异常，所以无法完全避免这种兼容性问题。</p></div><div class="columns is-variable is-1 is-multiline is-mobile"><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Android/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> Android</a></span><span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/OpenGLES/"><i class="fa fa-hashtag" aria-hidden="true" style="padding-right:3px"></i> OpenGLES</a></span></div><div class="columns is-mobile is-multiline article-nav"><span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev"></span> <span class="column is-12-mobile is-half-desktop article-nav-next"><a href="/article/dev/e7c3448c.html">Linux下罗技优联鼠标的简略指北</a></span></div><script>setArticleTime("article-time-763e0905","Wed Apr 22 2020 14:47:10 GMT+0800")</script></article><div class="sharebox"><div class="addthis_inline_share_toolbox"></div><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5af91abd06c0d49f"></script></div><div class="comments"><h3 class="title is-4">评论</h3><div id="valine-thread"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el:"#valine-thread",notify:!1,verify:!1,app_id:"GUCbjfNG4dzXp1OK5wLej8sB-gzGzoHsz",app_key:"8g2nRqttkIwqsgHOOsEzRvX2",placeholder:"我有一言，请诸位静听",avatar:"identicon"})</script></div></div></section><footer class="footer"><div class="container"><div class="columns content"><div class="column is-narrow has-text-centered"> &copy; 2020 Vincent Tam&nbsp; Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a></div><div class="column is-hidden-mobile"></div></div></div></footer><script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="//cdn.bootcss.com/outdated-browser/1.1.5/outdatedbrowser.min.js"></script><script>$(document).ready(function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script>window.FontAwesomeConfig={searchPseudoElements:!0}</script><script>window.MathJax={chtml:{matchFontHeight:!1},options:{ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"},tex:{autoload:{color:[],colorV2:["color"]},packages:{"[+]":["noerrors"]}},loader:{load:["input/asciimath","[tex]/noerrors"]}}</script><script src="//cdn.bootcss.com/mathjax/3.0.5/es5/tex-mml-chtml.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script><script>!function(e){e(document).ready(function(){"function"==typeof e.fn.lightGallery&&e(".article.gallery").lightGallery({selector:".gallery-item"}),"function"==typeof e.fn.justifiedGallery&&e(".justified-gallery").justifiedGallery()})}(jQuery)</script><script src="/js/script.js"></script><div class="searchbox ins-search"><div class="searchbox-mask"></div><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"> <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索"><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script></body></html>